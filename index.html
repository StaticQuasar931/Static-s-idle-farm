<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Idle Farm Simulator</title>
    <style>
        /* Basic Styling */
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            background: linear-gradient(to bottom, #a1c4fd, #c2e9fb);
            color: #000;
            margin: 0;
            padding: 0;
            transition: background 0.5s, color 0.5s;
        }
        h1 {
            margin-top: 20px;
            font-size: 3em;
        }
        .farm {
            margin: 20px;
            background-color: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .section {
            margin: 20px 0;
        }
        .crop, .animal, .upgrade, .quest, .achievement, .decoration, .passive-farm, .pet, .blackmarket, .minigame {
            margin: 15px;
            padding: 20px;
            border: 3px solid #4CAF50;
            border-radius: 15px;
            background-color: #fff;
            display: inline-block;
            width: 220px;
            position: relative;
            font-size: 1.2em;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.3s;
        }
        .crop:hover, .animal:hover, .upgrade:hover, .quest:hover, .achievement:hover, .decoration:hover, .passive-farm:hover, .pet:hover, .blackmarket:hover, .minigame:hover {
            background-color: #f0f0f0;
            transform: scale(1.05);
        }
        .emoji {
            font-size: 3em;
        }
        .button-outline {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 6px solid #4CAF50;
            border-radius: 10px;
            animation: buttonOutlineProgress linear;
            animation-timing-function: ease-in-out;
            animation-iteration-count: 1;
            pointer-events: none;
            transform-origin: left;
        }
        @keyframes buttonOutlineProgress {
            0% {
                transform: scaleX(0);
            }
            100% {
                transform: scaleX(1);
            }
        }
        /* Notification Container */
        #notification-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
        }
        /* Achievements Section */
        #achievements-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
        }
        .achievement {
            border: 2px solid #FFD700;
            background-color: #FFFACD;
        }
        /* Quests Section */
        #quests-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
        }
        /* Upgrades Section */
        #upgrades-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
        }
        /* Decorations Section */
        #decorations-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
        }
        /* Passive Farms Section */
        #passive-farms-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
        }
        /* Pets Section */
        #pets-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
        }
        /* Black Market Section */
        #blackmarket-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
        }
        /* Mini Games Section */
        #minigame-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
        }
        /* Tooltips */
        .tooltip {
            position: relative;
            display: inline-block;
        }
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 180px;
            background-color: #555;
            color: #fff;
            text-align: left;
            border-radius: 6px;
            padding: 10px;
            position: absolute;
            z-index: 1;
            bottom: 125%; /* Position above */
            left: 50%;
            margin-left: -90px;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        /* Progress Bars */
        .progress-bar {
            width: 100%;
            background-color: #ddd;
            border-radius: 5px;
            overflow: hidden;
            margin-top: 10px;
        }
        .progress-bar-inner {
            height: 20px;
            width: 0%;
            background-color: #4CAF50;
            transition: width 1s linear;
        }
        /* Focus Mode */
        #focus-mode-toggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 10px 20px;
            background-color: #4CAF50;
            color: #fff;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        #focus-mode-toggle:hover {
            background-color: #45a049;
        }
        /* Theme Toggle */
        #theme-toggle {
            position: fixed;
            bottom: 80px;
            right: 20px;
            padding: 10px 20px;
            background-color: #4CAF50;
            color: #fff;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        #theme-toggle:hover {
            background-color: #45a049;
        }
        /* Responsive Design */
        @media (max-width: 768px) {
            .crop, .animal, .upgrade, .quest, .achievement, .decoration, .passive-farm, .pet, .blackmarket, .minigame {
                width: 80%;
                margin: 10px auto;
                display: block;
            }
        }
        /* Dark Mode Styles */
        body.dark-mode {
            background: linear-gradient(to bottom, #2c3e50, #4ca1af);
            color: #fff;
        }
        body.dark-mode .farm {
            background-color: rgba(0, 0, 0, 0.8);
            color: #fff;
        }
        body.dark-mode .crop, 
        body.dark-mode .animal, 
        body.dark-mode .upgrade, 
        body.dark-mode .quest, 
        body.dark-mode .achievement, 
        body.dark-mode .decoration, 
        body.dark-mode .passive-farm,
        body.dark-mode .pet,
        body.dark-mode .blackmarket,
        body.dark-mode .minigame {
            background-color: #34495e;
            border-color: #1abc9c;
            color: #ecf0f1;
        }
        body.dark-mode .tooltip .tooltiptext {
            background-color: #333;
        }
        body.dark-mode .progress-bar {
            background-color: #555;
        }
        body.dark-mode .progress-bar-inner {
            background-color: #1abc9c;
        }
        body.dark-mode #focus-mode-toggle, 
        body.dark-mode #theme-toggle {
            background-color: #1abc9c;
        }
        /* Auto-Save Notification */
        #auto-save-notification {
            position: fixed;
            bottom: 140px;
            right: 20px;
            padding: 10px 20px;
            background-color: #4CAF50;
            color: #fff;
            border: none;
            border-radius: 10px;
            display: none;
            z-index: 1001;
            transition: opacity 0.5s;
        }
        /* Hidden Credits */
        .hidden-credits {
            display: none;
        }
    </style>
</head>
<body>
    <h1>Idle Farm Simulator üåæ</h1>
    <p>Made by <a href="https://sites.google.com/view/staticquasar931" style="color: #ff8800">Static</a></p>
    <button onclick="window.location.href='https://sites.google.com/view/staticquasar931/static-gmes/statics-idle-farm-sim'" style="margin-top: 10px; padding: 10px 20px; font-size: 1em; cursor: pointer;">Play Game</button>
    
    <div class="farm">
        <!-- Currencies Display -->
        <div class="section">
            <p>Coins: <span id="coins">0</span> üí∞ | Gems: <span id="gems">0</span> üíé | Tokens: <span id="tokens">0</span> üèÜ</p>
            <p id="auto-save-advertisement" style="font-size: 0.9em; color: #555;">Game progress is automatically saved! üõ°Ô∏è</p>
        </div>
        
        <!-- Crops Section -->
        <div class="section">
            <h2>Crops üå±</h2>
            <div id="crops-container">
                <div class="crop" id="wheat" onclick="grow('wheat', 10)">
                    <div class="emoji">üåæ</div>
                    <h3>Wheat</h3>
                    <p>Growth Time: <span id="wheatGrowth">5</span>s</p>
                    <div id="wheatButtonOutline" class="button-outline" style="display: none;"></div>
                    <div class="progress-bar">
                        <div id="wheatProgress" class="progress-bar-inner"></div>
                    </div>
                </div>
                <div class="crop" id="corn" onclick="grow('corn', 15)">
                    <div class="emoji">üåΩ</div>
                    <h3>Corn</h3>
                    <p>Growth Time: <span id="cornGrowth">8</span>s</p>
                    <div id="cornButtonOutline" class="button-outline" style="display: none;"></div>
                    <div class="progress-bar">
                        <div id="cornProgress" class="progress-bar-inner"></div>
                    </div>
                </div>
                <div class="crop" id="pumpkin" onclick="grow('pumpkin', 25)">
                    <div class="emoji">üéÉ</div>
                    <h3>Pumpkin</h3>
                    <p>Growth Time: <span id="pumpkinGrowth">12</span>s</p>
                    <div id="pumpkinButtonOutline" class="button-outline" style="display: none;"></div>
                    <div class="progress-bar">
                        <div id="pumpkinProgress" class="progress-bar-inner"></div>
                    </div>
                </div>
                <!-- Additional Crops -->
                <div class="crop" id="tomato" onclick="grow('tomato', 20)">
                    <div class="emoji">üçÖ</div>
                    <h3>Tomato</h3>
                    <p>Growth Time: <span id="tomatoGrowth">7</span>s</p>
                    <div id="tomatoButtonOutline" class="button-outline" style="display: none;"></div>
                    <div class="progress-bar">
                        <div id="tomatoProgress" class="progress-bar-inner"></div>
                    </div>
                </div>
                <div class="crop" id="carrot" onclick="grow('carrot', 12)">
                    <div class="emoji">ü•ï</div>
                    <h3>Carrot</h3>
                    <p>Growth Time: <span id="carrotGrowth">6</span>s</p>
                    <div id="carrotButtonOutline" class="button-outline" style="display: none;"></div>
                    <div class="progress-bar">
                        <div id="carrotProgress" class="progress-bar-inner"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Animals Section -->
        <div class="section">
            <h2>Animals üêÑ</h2>
            <div id="animals-container">
                <div class="animal" id="chicken" onclick="grow('chicken', 20)">
                    <div class="emoji">üêî</div>
                    <h3>Chicken</h3>
                    <p>Egg Time: <span id="chickenProduction">10</span>s</p>
                    <div id="chickenButtonOutline" class="button-outline" style="display: none;"></div>
                    <div class="progress-bar">
                        <div id="chickenProgress" class="progress-bar-inner"></div>
                    </div>
                </div>
                <div class="animal" id="cow" onclick="grow('cow', 30)">
                    <div class="emoji">üêÑ</div>
                    <h3>Cow</h3>
                    <p>Milk Time: <span id="cowProduction">15</span>s</p>
                    <div id="cowButtonOutline" class="button-outline" style="display: none;"></div>
                    <div class="progress-bar">
                        <div id="cowProgress" class="progress-bar-inner"></div>
                    </div>
                </div>
                <div class="animal" id="sheep" onclick="grow('sheep', 40)">
                    <div class="emoji">üêë</div>
                    <h3>Sheep</h3>
                    <p>Wool Time: <span id="sheepProduction">20</span>s</p>
                    <div id="sheepButtonOutline" class="button-outline" style="display: none;"></div>
                    <div class="progress-bar">
                        <div id="sheepProgress" class="progress-bar-inner"></div>
                    </div>
                </div>
                <div class="animal" id="goat" onclick="grow('goat', 50)">
                    <div class="emoji">üêê</div>
                    <h3>Goat</h3>
                    <p>Milk Time: <span id="goatProduction">18</span>s</p>
                    <div id="goatButtonOutline" class="button-outline" style="display: none;"></div>
                    <div class="progress-bar">
                        <div id="goatProgress" class="progress-bar-inner"></div>
                    </div>
                </div>
                <!-- Additional Animals -->
                <div class="animal" id="duck" onclick="grow('duck', 25)">
                    <div class="emoji">ü¶Ü</div>
                    <h3>Duck</h3>
                    <p>Egg Time: <span id="duckProduction">12</span>s</p>
                    <div id="duckButtonOutline" class="button-outline" style="display: none;"></div>
                    <div class="progress-bar">
                        <div id="duckProgress" class="progress-bar-inner"></div>
                    </div>
                </div>
                <div class="animal" id="pig" onclick="grow('pig', 35)">
                    <div class="emoji">üêñ</div>
                    <h3>Pig</h3>
                    <p>Truffle Time: <span id="pigProduction">25</span>s</p>
                    <div id="pigButtonOutline" class="button-outline" style="display: none;"></div>
                    <div class="progress-bar">
                        <div id="pigProgress" class="progress-bar-inner"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Upgrades Section -->
        <div class="section">
            <h2>Upgrades üöú</h2>
            <div id="upgrades-container">
                <div class="upgrade tooltip" onclick="buyFertilizer()">
                    <h3>Buy Fertilizer</h3>
                    <p>(50 coins)</p>
                    <span class="tooltiptext">Reduces wheat and chicken growth times by 1s.</span>
                </div>
                <div class="upgrade tooltip" onclick="buyTractor()">
                    <h3>Buy Tractor</h3>
                    <p>(150 coins)</p>
                    <span class="tooltiptext">Reduces corn and cow production times by 2s.</span>
                </div>
                <div class="upgrade tooltip" onclick="buyBarn()">
                    <h3>Buy Barn</h3>
                    <p>(300 coins)</p>
                    <span class="tooltiptext">Allows you to keep more animals.</span>
                </div>
                <div class="upgrade tooltip" onclick="buyGreenhouse()">
                    <h3>Buy Greenhouse</h3>
                    <p>(500 coins)</p>
                    <span class="tooltiptext">Reduces pumpkin growth time by 3s.</span>
                </div>
                <div class="upgrade tooltip" onclick="buyIrrigation()">
                    <h3>Buy Irrigation</h3>
                    <p>(800 coins)</p>
                    <span class="tooltiptext">Reduces wheat and corn growth times by 2s.</span>
                </div>
                <div class="upgrade tooltip" onclick="buyWindmill()">
                    <h3>Buy Windmill</h3>
                    <p>(1000 coins)</p>
                    <span class="tooltiptext">Reduces sheep and goat production times by 5s.</span>
                </div>
                <div class="upgrade tooltip" onclick="buyMarket()">
                    <h3>Buy Market</h3>
                    <p>(2000 coins)</p>
                    <span class="tooltiptext">Increases coin rewards by 10%.</span>
                </div>
                <!-- Upgrade Tiers -->
                <div class="upgrade tooltip" onclick="buyAdvancedTractor()">
                    <h3>Advanced Tractor</h3>
                    <p>(5000 coins)</p>
                    <span class="tooltiptext">Further reduces corn and cow production times by 3s.</span>
                </div>
                <div class="upgrade tooltip" onclick="buySuperWindmill()">
                    <h3>Super Windmill</h3>
                    <p>(8000 coins)</p>
                    <span class="tooltiptext">Further reduces sheep and goat production times by 5s.</span>
                </div>
            </div>
        </div>
        
        <!-- Passive Farms Section -->
        <div class="section">
            <h2>Passive Farms üåæ</h2>
            <div id="passive-farms-container">
                <div class="passive-farm" id="passiveCrop1" onclick="buyPassiveCrop('passiveCrop1', 500)">
                    <h3>Passive Wheat Farm</h3>
                    <p>Cost: 500 coins</p>
                    <p>Generates 5 coins every 10s</p>
                </div>
                <div class="passive-farm" id="passiveAnimal1" onclick="buyPassiveAnimal('passiveAnimal1', 1000)">
                    <h3>Passive Chicken Coop</h3>
                    <p>Cost: 1000 coins</p>
                    <p>Generates 15 coins every 20s</p>
                </div>
            </div>
        </div>
        
        <!-- Decorations Section -->
        <div class="section">
            <h2>Decorations üé®</h2>
            <div id="decorations-container">
                <div class="decoration tooltip" onclick="buyDecoration('statue', 300)">
                    <h3>Statue</h3>
                    <p>(300 coins)</p>
                    <span class="tooltiptext">Beautify your farm. No gameplay effect.</span>
                </div>
                <div class="decoration tooltip" onclick="buyDecoration('fountain', 500)">
                    <h3>Fountain</h3>
                    <p>(500 coins)</p>
                    <span class="tooltiptext">Adds a fountain to your farm. No gameplay effect.</span>
                </div>
            </div>
        </div>
        
        <!-- Quests Section -->
        <div class="section">
            <h2>Quests üéØ</h2>
            <div id="quests-container">
                <!-- Quests will be dynamically added here -->
            </div>
        </div>
        
        <!-- Achievements Section -->
        <div class="section">
            <h2>Achievements üèÜ</h2>
            <div id="achievements-container">
                <!-- Achievements will be dynamically added here -->
            </div>
        </div>
        
        <!-- Pets Section -->
        <div class="section">
            <h2>Pets üêæ</h2>
            <div id="pets-container">
                <div class="pet" id="pet1" onclick="spinPetWheel()">
                    <h3>Buy a Pet</h3>
                    <p>(Use Tokens)</p>
                </div>
                <!-- Additional Pets will be dynamically added here -->
            </div>
        </div>
        
        <!-- Black Market Section -->
        <div class="section">
            <h2>Black Market üí±</h2>
            <div id="blackmarket-container">
                <!-- Black Market items will be dynamically added here -->
            </div>
        </div>
        
        <!-- Mini Games Section -->
        <div class="section">
            <h2>Mini Games üïπÔ∏è</h2>
            <div id="minigame-container">
                <div class="minigame tooltip" onclick="openMiniGame('flappyBird')">
                    <h3>Flappy Farm üê•</h3>
                    <p>Play and earn tokens!</p>
                    <span class="tooltiptext">A simple Flappy Bird-like game to earn tokens.</span>
                </div>
                <!-- Additional Mini Games can be added here -->
            </div>
        </div>
        
        <!-- Prestige Section -->
        <div class="section">
            <h2>Prestige ‚ú®</h2>
            <button onclick="prestige()" style="padding: 10px 20px; font-size: 1em; cursor: pointer;">Reset for Prestige (1000 Coins)</button>
            <p>Prestige Count: <span id="prestigeCount">0</span></p>
            <p>Coin Multiplier: x<span id="coinMultiplier">1</span></p>
        </div>
    </div>
    
    <!-- Notification Container -->
    <div id="notification-container"></div>
    
    <!-- Auto-Save Notification -->
    <div id="auto-save-notification">Game has been auto-saved! ‚úÖ</div>
    
    <!-- Audio Elements -->
    <audio id="coinSound" src="https://www.soundjay.com/button/sounds/button-16.mp3" preload="auto"></audio>
    <audio id="achievementSound" src="https://www.soundjay.com/misc/sounds/bell-ringing-05.mp3" preload="auto"></audio>
    <audio id="upgradeSound" src="https://www.soundjay.com/button/sounds/button-4.mp3" preload="auto"></audio>
    <audio id="prestigeSound" src="https://www.soundjay.com/misc/sounds/bell-ringing-03.mp3" preload="auto"></audio>
    <audio id="decorationSound" src="https://www.soundjay.com/button/sounds/button-10.mp3" preload="auto"></audio>
    <audio id="passiveSound" src="https://www.soundjay.com/button/sounds/button-09.mp3" preload="auto"></audio>
    <audio id="dailyBonusSound" src="https://www.soundjay.com/misc/sounds/bell-ringing-07.mp3" preload="auto"></audio>
    <audio id="tokenSound" src="https://www.soundjay.com/button/sounds/button-10.mp3" preload="auto"></audio>
    <audio id="petSound" src="https://www.soundjay.com/button/sounds/button-3.mp3" preload="auto"></audio>
    
    <!-- Focus Mode and Theme Toggle Buttons -->
    <button id="focus-mode-toggle" onclick="toggleFocusMode()">üîí Focus Mode</button>
    <button id="theme-toggle" onclick="toggleTheme()">üåó Toggle Theme</button>
    
    <!-- Mini Game Container -->
    <div id="miniGameContainer" style="display:none;">
        <iframe id="miniGameFrame" src="" width="100%" height="600px" style="border:none;"></iframe>
        <button onclick="closeMiniGame()" style="margin-top: 10px; padding: 10px 20px; font-size: 1em; cursor: pointer;">Close Game</button>
    </div>
    
    <script>
        // Game Variables
        let coins = 0;
        let gems = 0;
        let tokens = 0;
        let growthTimers = {};
        let passiveTimers = {};
        let growthTimes = {
            wheat: 5,
            corn: 8,
            pumpkin: 12,
            tomato: 7,
            carrot: 6,
            chicken: 10,
            cow: 15,
            sheep: 20,
            goat: 18,
            duck: 12,
            pig: 25
        };
        let baseRewards = {
            wheat: 10,
            corn: 15,
            pumpkin: 25,
            tomato: 20,
            carrot: 12,
            chicken: 20,
            cow: 30,
            sheep: 40,
            goat: 50,
            duck: 25,
            pig: 35
        };
        let activeNotifications = 0;
        const maxNotifications = 3;
        let achievements = {};
        let quests = [];
        let completedQuests = [];
        let prestigeCount = 0;
        let coinMultiplier = 1;
        let focusMode = false;
        let theme = 'light';
        let dailyBonusClaimed = false;
        let playerNetWorth = 0;
        
        // NPC Trading Variables
        const npcs = generateNPCs();
        
        // Sound Effects
        const coinSound = document.getElementById('coinSound');
        const achievementSound = document.getElementById('achievementSound');
        const upgradeSound = document.getElementById('upgradeSound');
        const prestigeSound = document.getElementById('prestigeSound');
        const decorationSound = document.getElementById('decorationSound');
        const passiveSound = document.getElementById('passiveSound');
        const dailyBonusSound = document.getElementById('dailyBonusSound');
        const tokenSound = document.getElementById('tokenSound');
        const petSound = document.getElementById('petSound');
        
        // Initialization
        window.onload = function() {
            loadGame();
            generateQuests();
            generateAchievements();
            updateCoins();
            updateGems();
            updateTokens();
            updatePrestige();
            renderQuests();
            renderAchievements();
            renderBlackMarket();
            renderNPCs();
            checkDailyBonus();
            startPassiveIncome();
            updateTheme();
            showAutoSaveNotification();
            startNPCAutoContact();
        };
        
        window.onbeforeunload = saveGame;
        
        // Grow Function
        function grow(item, reward) {
            if (!growthTimers[item]) {
                let outline = document.getElementById(`${item}ButtonOutline`);
                outline.style.display = 'block';
                outline.style.animationDuration = `${growthTimes[item]}s`;
                
                // Start Progress Bar
                let progressBar = document.getElementById(`${item}Progress`);
                progressBar.style.width = '0%';
                setTimeout(() => {
                    progressBar.style.width = '100%';
                }, 100);
                
                growthTimers[item] = setTimeout(() => {
                    coins += reward * coinMultiplier;
                    playerNetWorth += reward * coinMultiplier;
                    coinSound.play();
                    updateCoins();
                    alertInGame(`${capitalize(item)} collected! +${reward * coinMultiplier} coins`);
                    growthTimers[item] = null;
                    outline.style.display = 'none';
                    progressBar.style.width = '0%';
                    checkAchievements(item);
                    checkQuests(item);
                }, growthTimes[item] * 1000);
            }
        }
        
        // Passive Income Functions
        function buyPassiveCrop(id, cost) {
            if (coins >= cost && !document.getElementById(id).classList.contains('owned')) {
                coins -= cost;
                document.getElementById(id).classList.add('owned');
                passiveSound.play();
                alertInGame('Passive Wheat Farm purchased! üí∞ Generates 5 coins every 10s.');
                startPassiveIncomeItem(id, 10, 5);
                updateCoins();
                playerNetWorth += cost;
                checkAchievements(null); // For passive farm achievements
            } else {
                alertInGame('Not enough coins or already owned!');
            }
        }
        
        function buyPassiveAnimal(id, cost) {
            if (coins >= cost && !document.getElementById(id).classList.contains('owned')) {
                coins -= cost;
                document.getElementById(id).classList.add('owned');
                passiveSound.play();
                alertInGame('Passive Chicken Coop purchased! üí∞ Generates 15 coins every 20s.');
                startPassiveIncomeItem(id, 20, 15);
                updateCoins();
                playerNetWorth += cost;
                checkAchievements(null); // For passive farm achievements
            } else {
                alertInGame('Not enough coins or already owned!');
            }
        }
        
        function startPassiveIncomeItem(id, interval, amount) {
            passiveTimers[id] = setInterval(() => {
                coins += amount * coinMultiplier;
                playerNetWorth += amount * coinMultiplier;
                coinSound.play();
                updateCoins();
                alertInGame(`Passive income: +${amount * coinMultiplier} coins from ${capitalize(id.replace('passive', '').toLowerCase())}`);
            }, interval * 1000);
        }
        
        function startPassiveIncome() {
            // Initialize existing passive farms
            ['passiveCrop1', 'passiveAnimal1'].forEach(id => {
                if (document.getElementById(id).classList.contains('owned')) {
                    if (id === 'passiveCrop1') {
                        startPassiveIncomeItem(id, 10, 5);
                    }
                    if (id === 'passiveAnimal1') {
                        startPassiveIncomeItem(id, 20, 15);
                    }
                }
            });
        }
        
        // Buy Upgrades
        function buyFertilizer() {
            if (coins >= 50) {
                coins -= 50;
                growthTimes.wheat = Math.max(1, growthTimes.wheat - 1);
                growthTimes.chicken = Math.max(5, growthTimes.chicken - 1);
                upgradeSound.play();
                alertInGame('Fertilizer purchased! üå± Wheat and Chicken growth times decreased by 1s.');
                updateCoins();
                playerNetWorth += 50;
                checkAchievements(null); // For any relevant achievements
            } else {
                alertInGame('Not enough coins!');
            }
        }
        
        function buyTractor() {
            if (coins >= 150) {
                coins -= 150;
                growthTimes.corn = Math.max(4, growthTimes.corn - 2);
                growthTimes.cow = Math.max(10, growthTimes.cow - 2);
                upgradeSound.play();
                alertInGame('Tractor purchased! üöú Corn and Cow production times decreased by 2s.');
                updateCoins();
                playerNetWorth += 150;
                checkAchievements(null); // For any relevant achievements
            } else {
                alertInGame('Not enough coins!');
            }
        }
        
        function buyBarn() {
            if (coins >= 300) {
                coins -= 300;
                // Implement barn functionality (e.g., increase animal capacity)
                upgradeSound.play();
                alertInGame('Barn purchased! üè† You can now keep more animals!');
                updateCoins();
                playerNetWorth += 300;
                checkAchievements(null); // For any relevant achievements
            } else {
                alertInGame('Not enough coins!');
            }
        }
        
        function buyGreenhouse() {
            if (coins >= 500) {
                coins -= 500;
                growthTimes.pumpkin = Math.max(6, growthTimes.pumpkin - 3);
                upgradeSound.play();
                alertInGame('Greenhouse purchased! üåø Pumpkin growth time decreased by 3s.');
                updateCoins();
                playerNetWorth += 500;
                checkAchievements(null); // For any relevant achievements
            } else {
                alertInGame('Not enough coins!');
            }
        }
        
        function buyIrrigation() {
            if (coins >= 800) {
                coins -= 800;
                growthTimes.wheat = Math.max(1, growthTimes.wheat - 2);
                growthTimes.corn = Math.max(2, growthTimes.corn - 2);
                upgradeSound.play();
                alertInGame('Irrigation System purchased! üí¶ Wheat and Corn growth times decreased by 2s.');
                updateCoins();
                playerNetWorth += 800;
                checkAchievements(null); // For any relevant achievements
            } else {
                alertInGame('Not enough coins!');
            }
        }
        
        function buyWindmill() {
            if (coins >= 1000) {
                coins -= 1000;
                growthTimes.sheep = Math.max(10, growthTimes.sheep - 5);
                growthTimes.goat = Math.max(10, growthTimes.goat - 5);
                upgradeSound.play();
                alertInGame('Windmill purchased! üå¨Ô∏è Sheep and Goat production times decreased by 5s.');
                updateCoins();
                playerNetWorth += 1000;
                checkAchievements(null); // For any relevant achievements
            } else {
                alertInGame('Not enough coins!');
            }
        }
        
        function buyMarket() {
            if (coins >= 2000) {
                coins -= 2000;
                coinMultiplier += 0.1; // Increase coin rewards by 10%
                upgradeSound.play();
                alertInGame('Market purchased! üíº Coin rewards increased by 10%.');
                updateCoins();
                playerNetWorth += 2000;
                checkAchievements('market'); // For market-related achievements
            } else {
                alertInGame('Not enough coins!');
            }
        }
        
        function buyAdvancedTractor() {
            if (coins >= 5000) {
                coins -= 5000;
                growthTimes.corn = Math.max(2, growthTimes.corn - 3);
                growthTimes.cow = Math.max(7, growthTimes.cow - 3);
                upgradeSound.play();
                alertInGame('Advanced Tractor purchased! üöú Corn and Cow production times decreased by 3s.');
                updateCoins();
                playerNetWorth += 5000;
                checkAchievements(null); // For any relevant achievements
            } else {
                alertInGame('Not enough coins!');
            }
        }
        
        function buySuperWindmill() {
            if (coins >= 8000) {
                coins -= 8000;
                growthTimes.sheep = Math.max(5, growthTimes.sheep - 5);
                growthTimes.goat = Math.max(5, growthTimes.goat - 5);
                upgradeSound.play();
                alertInGame('Super Windmill purchased! üå¨Ô∏è Sheep and Goat production times decreased by 5s.');
                updateCoins();
                playerNetWorth += 8000;
                checkAchievements(null); // For any relevant achievements
            } else {
                alertInGame('Not enough coins!');
            }
        }
        
        // Buy Decorations
        function buyDecoration(decoration, cost) {
            if (coins >= cost) {
                coins -= cost;
                decorationSound.play();
                alertInGame(`${capitalize(decoration)} decoration added to your farm! üéâ`);
                updateCoins();
                playerNetWorth += cost;
                checkAchievements(null); // For any relevant achievements
            } else {
                alertInGame('Not enough coins!');
            }
        }
        
        // Update Coins Display
        function updateCoins() {
            document.getElementById('coins').innerText = coins;
        }
        
        // Update Gems Display
        function updateGems() {
            document.getElementById('gems').innerText = gems;
        }
        
        // Update Tokens Display
        function updateTokens() {
            document.getElementById('tokens').innerText = tokens;
        }
        
        // Update Prestige Display
        function updatePrestige() {
            document.getElementById('prestigeCount').innerText = prestigeCount;
            document.getElementById('coinMultiplier').innerText = coinMultiplier.toFixed(1);
        }
        
        // In-Game Notifications
        function alertInGame(message) {
            if (activeNotifications >= maxNotifications) return;
            activeNotifications++;
            let notification = document.createElement('div');
            notification.innerText = message;
            notification.style.padding = '10px 20px';
            notification.style.marginTop = '10px';
            notification.style.backgroundColor = '#ffcc00';
            notification.style.border = '2px solid #333';
            notification.style.borderRadius = '5px';
            notification.style.boxShadow = '0 2px 8px rgba(0,0,0,0.2)';
            notification.style.opacity = '0';
            notification.style.transition = 'opacity 0.5s';
            document.getElementById('notification-container').appendChild(notification);
            setTimeout(() => {
                notification.style.opacity = '1';
            }, 100);
            setTimeout(() => {
                notification.style.opacity = '0';
                setTimeout(() => {
                    notification.remove();
                    activeNotifications--;
                }, 500);
            }, 3000);
        }
        
        // Save Game State
        function saveGame() {
            const gameState = {
                coins,
                gems,
                tokens,
                growthTimes,
                prestigeCount,
                coinMultiplier,
                achievements,
                completedQuests,
                passiveFarms: getOwnedPassiveFarms(),
                theme,
                dailyBonusClaimed,
                playerNetWorth
            };
            localStorage.setItem('idleFarmGameState', JSON.stringify(gameState));
        }
        
        // Load Game State
        function loadGame() {
            const savedState = JSON.parse(localStorage.getItem('idleFarmGameState'));
            if (savedState) {
                coins = savedState.coins || 0;
                gems = savedState.gems || 0;
                tokens = savedState.tokens || 0;
                growthTimes = savedState.growthTimes || growthTimes;
                prestigeCount = savedState.prestigeCount || 0;
                coinMultiplier = savedState.coinMultiplier || 1;
                achievements = savedState.achievements || {};
                completedQuests = savedState.completedQuests || [];
                theme = savedState.theme || 'light';
                dailyBonusClaimed = savedState.dailyBonusClaimed || false;
                playerNetWorth = savedState.playerNetWorth || 0;
                
                // Restore passive farms
                if (savedState.passiveFarms) {
                    savedState.passiveFarms.forEach(id => {
                        document.getElementById(id).classList.add('owned');
                    });
                }
                
                updateCoins();
                updateGems();
                updateTokens();
                updatePrestige();
            }
        }
        
        // Prestige System
        function prestige() {
            if (coins >= 1000) {
                coins -= 1000;
                prestigeCount += 1;
                coinMultiplier += 0.5; // Increase multiplier
                updateCoins();
                updatePrestige();
                prestigeSound.play();
                alertInGame('Prestige achieved! ‚ú® Coin rewards increased by 50%.');
                checkAchievements(null); // For prestige-related achievements
                resetGame(false);
            } else {
                alertInGame('Not enough coins to prestige!');
            }
        }
        
        // Reset Game Function
        function resetGame(completeReset = true) {
            // Clear growth timers
            for (let key in growthTimers) {
                clearTimeout(growthTimers[key]);
            }
            growthTimers = {};
            
            // Clear passive timers
            for (let key in passiveTimers) {
                clearInterval(passiveTimers[key]);
            }
            passiveTimers = {};
            
            // Reset variables
            coins = 0;
            gems = 0;
            tokens = 0;
            growthTimes = {
                wheat: 5,
                corn: 8,
                pumpkin: 12,
                tomato: 7,
                carrot: 6,
                chicken: 10,
                cow: 15,
                sheep: 20,
                goat: 18,
                duck: 12,
                pig: 25
            };
            if (completeReset) {
                achievements = {};
                completedQuests = [];
                coinMultiplier = 1;
                document.querySelectorAll('.owned').forEach(el => el.classList.remove('owned'));
                document.querySelectorAll('.pet-owned').forEach(el => el.classList.remove('pet-owned'));
            }
            updateCoins();
            updateGems();
            updateTokens();
            updatePrestige();
            renderQuests();
            renderAchievements();
            renderBlackMarket();
            renderNPCs();
            generateQuests();
            generateAchievements();
            startPassiveIncome();
        }
        
        // Achievements System
        function generateAchievements() {
            const achievementList = [
                { id: 'ach1', description: 'Harvest 10 Wheat', goal: 10, type: 'crop', item: 'wheat', reward: '10 Gems' },
                { id: 'ach2', description: 'Harvest 50 Corn', goal: 50, type: 'crop', item: 'corn', reward: '20 Gems' },
                { id: 'ach3', description: 'Collect 1000 Coins', goal: 1000, type: 'coins', item: null, reward: '50 Gems' },
                { id: 'ach4', description: 'Raise 20 Chickens', goal: 20, type: 'animal', item: 'chicken', reward: '30 Gems' },
                { id: 'ach5', description: 'Unlock Market Upgrade', goal: 'market', type: 'upgrade', item: 'market', reward: '100 Gems' },
                { id: 'ach6', description: 'Prestige 1 Time', goal: 1, type: 'prestige', item: null, reward: '150 Gems' },
                { id: 'ach7', description: 'Own 1 Passive Farm', goal: 1, type: 'passive', item: null, reward: '200 Gems' },
                { id: 'ach8', description: 'Play 10 Mini Games', goal: 10, type: 'minigame', item: null, reward: '50 Tokens' },
                { id: 'ach9', description: 'Own 5 Pets', goal: 5, type: 'pet', item: null, reward: '100 Tokens' },
                { id: 'ach10', description: 'Trade with 5 NPCs', goal: 5, type: 'npc', item: null, reward: '200 Tokens' }
            ];
            achievementList.forEach(ach => {
                if (!achievements[ach.id]) {
                    achievements[ach.id] = { ...ach, achieved: false, count: 0 };
                }
            });
        }
        
        function checkAchievements(item, type) {
            for (let key in achievements) {
                let ach = achievements[key];
                if (!ach.achieved) {
                    if (ach.type === 'crop' && ach.item === item) {
                        ach.count += 1;
                        if (ach.count >= ach.goal) {
                            ach.achieved = true;
                            gems += 10;
                            achievementSound.play();
                            alertInGame(`Achievement Unlocked: ${ach.description} +${ach.reward}`);
                        }
                    }
                    if (ach.type === 'animal' && ach.item === item) {
                        ach.count += 1;
                        if (ach.count >= ach.goal) {
                            ach.achieved = true;
                            gems += 30;
                            achievementSound.play();
                            alertInGame(`Achievement Unlocked: ${ach.description} +${ach.reward}`);
                        }
                    }
                    if (ach.type === 'coins' && ach.item === null) {
                        if (coins >= ach.goal) {
                            ach.achieved = true;
                            gems += 50;
                            achievementSound.play();
                            alertInGame(`Achievement Unlocked: ${ach.description} +${ach.reward}`);
                        }
                    }
                    if (ach.type === 'upgrade' && ach.item === item) {
                        if (item === 'market' && coinMultiplier > 1) { // Assuming market increases multiplier
                            ach.achieved = true;
                            gems += 100;
                            achievementSound.play();
                            alertInGame(`Achievement Unlocked: ${ach.description} +${ach.reward}`);
                        }
                    }
                    if (ach.type === 'prestige' && ach.item === null) {
                        if (prestigeCount >= ach.goal) {
                            ach.achieved = true;
                            gems += 150;
                            achievementSound.play();
                            alertInGame(`Achievement Unlocked: ${ach.description} +${ach.reward}`);
                        }
                    }
                    if (ach.type === 'passive' && ach.item === null) {
                        if (getOwnedPassiveFarms().length >= ach.goal) {
                            ach.achieved = true;
                            gems += 200;
                            achievementSound.play();
                            alertInGame(`Achievement Unlocked: ${ach.description} +${ach.reward}`);
                        }
                    }
                    if (ach.type === 'minigame' && ach.item === null) {
                        ach.count += 1;
                        if (ach.count >= ach.goal) {
                            ach.achieved = true;
                            tokens += 50;
                            achievementSound.play();
                            alertInGame(`Achievement Unlocked: ${ach.description} +${ach.reward}`);
                        }
                    }
                    if (ach.type === 'pet' && ach.item === null) {
                        if (getOwnedPets().length >= ach.goal) {
                            ach.achieved = true;
                            tokens += 100;
                            achievementSound.play();
                            alertInGame(`Achievement Unlocked: ${ach.description} +${ach.reward}`);
                        }
                    }
                    if (ach.type === 'npc' && ach.item === null) {
                        ach.count += 1;
                        if (ach.count >= ach.goal) {
                            ach.achieved = true;
                            tokens += 200;
                            achievementSound.play();
                            alertInGame(`Achievement Unlocked: ${ach.description} +${ach.reward}`);
                        }
                    }
                }
            }
            renderAchievements();
            updateGems();
            updateTokens();
        }
        
        function renderAchievements() {
            const container = document.getElementById('achievements-container');
            container.innerHTML = '';
            for (let key in achievements) {
                let ach = achievements[key];
                let achDiv = document.createElement('div');
                achDiv.classList.add('achievement');
                achDiv.innerHTML = `<h4>${ach.achieved ? '‚úÖ' : 'üîÑ'} ${ach.description}</h4><p>Reward: ${ach.reward}</p>`;
                container.appendChild(achDiv);
            }
        }
        
        // Quests System
        function generateQuests() {
            const questList = [
                { id: 'quest1', description: 'Harvest 20 Wheat', goal: 20, type: 'crop', item: 'wheat', reward: 100 },
                { id: 'quest2', description: 'Collect 500 Coins', goal: 500, type: 'coins', item: null, reward: 50 },
                { id: 'quest3', description: 'Buy 2 Upgrades', goal: 2, type: 'upgrade', item: null, reward: 150 },
                { id: 'quest4', description: 'Raise 10 Chickens', goal: 10, type: 'animal', item: 'chicken', reward: 200 },
                { id: 'quest5', description: 'Own 1 Passive Farm', goal: 1, type: 'passive', item: null, reward: 300 },
                { id: 'quest6', description: 'Play 5 Mini Games', goal: 5, type: 'minigame', item: null, reward: 100 },
                { id: 'quest7', description: 'Own 3 Pets', goal: 3, type: 'pet', item: null, reward: 200 },
                { id: 'quest8', description: 'Trade with 2 NPCs', goal: 2, type: 'npc', item: null, reward: 150 }
            ];
            quests = questList.filter(q => !completedQuests.includes(q.id));
        }
        
        function checkQuests(item, type) {
            quests.forEach(quest => {
                if (!completedQuests.includes(quest.id)) {
                    if (quest.type === 'crop' && quest.item === item) {
                        quest.count = (quest.count || 0) + 1;
                        if (quest.count >= quest.goal) {
                            completeQuest(quest);
                        }
                    }
                    if (quest.type === 'animal' && quest.item === item) {
                        quest.count = (quest.count || 0) + 1;
                        if (quest.count >= quest.goal) {
                            completeQuest(quest);
                        }
                    }
                    if (quest.type === 'coins' && quest.item === null) {
                        if (coins >= quest.goal) {
                            completeQuest(quest);
                        }
                    }
                    if (quest.type === 'upgrade' && quest.item === null) {
                        // Assuming each upgrade counts as one
                        quest.count = (quest.count || 0) + 1;
                        if (quest.count >= quest.goal) {
                            completeQuest(quest);
                        }
                    }
                    if (quest.type === 'passive' && quest.item === null) {
                        if (getOwnedPassiveFarms().length >= quest.goal) {
                            completeQuest(quest);
                        }
                    }
                    if (quest.type === 'minigame' && quest.item === null) {
                        // Increment when mini-game is played
                        quest.count = (quest.count || 0) + 1;
                        if (quest.count >= quest.goal) {
                            completeQuest(quest);
                        }
                    }
                    if (quest.type === 'pet' && quest.item === null) {
                        if (getOwnedPets().length >= quest.goal) {
                            completeQuest(quest);
                        }
                    }
                    if (quest.type === 'npc' && quest.item === null) {
                        quest.count = (quest.count || 0) + 1;
                        if (quest.count >= quest.goal) {
                            completeQuest(quest);
                        }
                    }
                }
            });
        }
        
        function completeQuest(quest) {
            coins += quest.reward;
            playerNetWorth += quest.reward;
            alertInGame(`Quest Completed: ${quest.description} +${quest.reward} coins!`);
            completedQuests.push(quest.id);
            quests = quests.filter(q => q.id !== quest.id);
            generateQuests();
            renderQuests();
            updateCoins();
            checkAchievements(quest.item, quest.type);
        }
        
        function renderQuests() {
            const container = document.getElementById('quests-container');
            container.innerHTML = '';
            quests.forEach(quest => {
                if (!completedQuests.includes(quest.id)) {
                    let questDiv = document.createElement('div');
                    questDiv.classList.add('quest');
                    questDiv.innerHTML = `<h4>${quest.description}</h4><p>Reward: ${quest.reward} coins</p>`;
                    container.appendChild(questDiv);
                }
            });
        }
        
        // Black Market System
        let blackMarketItems = [];
        function generateBlackMarketItems() {
            const baseAnimals = ['üê∂', 'üê±', 'ü¶ä', 'üê∞', 'üêª'];
            const rarities = ['Common', 'Uncommon', 'Rare', 'Epic', 'Mythic'];
            blackMarketItems = [];
            baseAnimals.forEach(animal => {
                rarities.forEach(rarity => {
                    let cost = 100;
                    switch(rarity) {
                        case 'Common':
                            cost = 100;
                            break;
                        case 'Uncommon':
                            cost = 300;
                            break;
                        case 'Rare':
                            cost = 600;
                            break;
                        case 'Epic':
                            cost = 1000;
                            break;
                        case 'Mythic':
                            cost = 2000;
                            break;
                    }
                    blackMarketItems.push({
                        animal: animal,
                        rarity: rarity,
                        cost: cost,
                        benefits: getBenefitsByRarity(rarity)
                    });
                });
            });
        }
        
        function getBenefitsByRarity(rarity) {
            switch(rarity) {
                case 'Common':
                    return { coinBoost: 1 };
                case 'Uncommon':
                    return { coinBoost: 1.5 };
                case 'Rare':
                    return { coinBoost: 2 };
                case 'Epic':
                    return { coinBoost: 3 };
                case 'Mythic':
                    return { coinBoost: 5 };
                default:
                    return { coinBoost: 1 };
            }
        }
        
        function renderBlackMarket() {
            const container = document.getElementById('blackmarket-container');
            container.innerHTML = '';
            blackMarketItems.forEach((item, index) => {
                let itemDiv = document.createElement('div');
                itemDiv.classList.add('blackmarket');
                itemDiv.innerHTML = `
                    <div class="emoji">${item.animal}</div>
                    <h3>${item.rarity} Animal</h3>
                    <p>Cost: ${item.cost} coins</p>
                    <button onclick="buyBlackMarketItem(${index})" style="margin-top:10px; padding:5px 10px; cursor:pointer;">Buy</button>
                `;
                container.appendChild(itemDiv);
            });
        }
        
        function buyBlackMarketItem(index) {
            const item = blackMarketItems[index];
            if (coins >= item.cost) {
                coins -= item.cost;
                tokens += 1; // Reward token for purchase
                playerNetWorth += item.cost;
                alertInGame(`Purchased ${item.rarity} Animal ${item.animal}! +${item.benefits.coinBoost}x coins from this animal.`);
                upgradeSound.play();
                addBlackMarketAnimal(item);
                updateCoins();
                updateTokens();
                checkAchievements(null, null);
            } else {
                alertInGame('Not enough coins!');
            }
        }
        
        function addBlackMarketAnimal(item) {
            // Add to animal section with benefits
            const animalContainer = document.getElementById(`${getAnimalName(item.animal)}-container`);
            if (!animalContainer) return;
            let newAnimal = document.createElement('div');
            newAnimal.classList.add('animal');
            newAnimal.innerHTML = `
                <div class="emoji">${item.animal}</div>
                <h3>${getAnimalName(item.animal)}</h3>
                <p>Coin Boost: x${item.benefits.coinBoost}</p>
                <p>Owned: <span id="${getAnimalName(item.animal)}Count">1</span></p>
                <button onclick="buyMore('${getAnimalName(item.animal)}', ${item.cost})" style="margin-top:10px; padding:5px 10px; cursor:pointer;">Buy More</button>
            `;
            animalContainer.appendChild(newAnimal);
        }
        
        function getAnimalName(emoji) {
            const map = {
                'üê∂': 'dog',
                'üê±': 'cat',
                'ü¶ä': 'fox',
                'üê∞': 'rabbit',
                'üêª': 'bear'
            };
            return map[emoji] || 'animal';
        }
        
        // NPC Trading System
        function generateNPCs() {
            const names = ['Woody', 'Lily', 'Max', 'Bella', 'Charlie', 'Daisy', 'Rocky', 'Molly', 'Buddy', 'Lucy', 'Jack', 'Luna', 'Oliver', 'Chloe', 'Toby'];
            const categories = ['Bronze', 'Silver', 'Gold', 'Platinum', 'Diamond'];
            let npcList = [];
            categories.forEach((category, catIndex) => {
                for (let i = 0; i < 3; i++) {
                    npcList.push({
                        name: names[catIndex * 3 + i],
                        category: category,
                        contactChance: catIndex + 1, // Higher category, higher chance
                        offeredAnimal: getRandomMythicAnimal(category),
                        pet: getRandomPet(category)
                    });
                }
            });
            return npcList;
        }
        
        function getRandomMythicAnimal(category) {
            const mythicAnimals = {
                'Bronze': 'ü¶Å', // Example
                'Silver': 'üêâ',
                'Gold': 'ü¶Ñ',
                'Platinum': 'üê≤',
                'Diamond': 'üê∫'
            };
            return mythicAnimals[category] || 'ü¶ä';
        }
        
        function getRandomPet(category) {
            const pets = {
                'Bronze': { name: 'Pup', benefit: 'moneyBoost', value: 1.1 },
                'Silver': { name: 'Kitty', benefit: 'timeBoost', value: 1.2 },
                'Gold': { name: 'Dragon', benefit: 'coinMultiplier', value: 1.3 },
                'Platinum': { name: 'Unicorn', benefit: 'allBoost', value: 1.4 },
                'Diamond': { name: 'Phoenix', benefit: 'autoHarvest', value: 1.5 }
            };
            return pets[category] || { name: 'Pet', benefit: 'none', value: 1 };
        }
        
        function renderNPCs() {
            // Placeholder for NPC rendering if needed
        }
        
        function startNPCAutoContact() {
            setInterval(() => {
                const chance = Math.random() * 10;
                if (chance < 1) { // Adjust probability as needed
                    contactNPC();
                }
            }, 300000); // Every 5 minutes
        }
        
        function contactNPC() {
            const filteredNPCs = npcs.filter(npc => Math.random() < (npc.contactChance / 10));
            if (filteredNPCs.length === 0) return;
            const npc = filteredNPCs[Math.floor(Math.random() * filteredNPCs.length)];
            const accept = confirm(`${npc.name} from ${npc.category} category wants to trade! Accept?`);
            if (accept) {
                tokens += 5;
                coins += 500 * coinMultiplier; // Example trade deal
                alertInGame(`Trade accepted with ${npc.name}! +500 coins and +5 tokens.`);
                playerNetWorth += 500 * coinMultiplier;
                checkQuests(null, 'npc');
                checkAchievements(null, 'npc');
            } else {
                alertInGame(`Trade with ${npc.name} declined.`);
            }
        }
        
        // Pets System
        let availablePets = [
            { name: 'Pup', rarity: 'Common', benefit: 'moneyBoost', value: 1.1 },
            { name: 'Kitty', rarity: 'Uncommon', benefit: 'timeBoost', value: 1.2 },
            { name: 'Dragon', rarity: 'Rare', benefit: 'coinMultiplier', value: 1.3 },
            { name: 'Unicorn', rarity: 'Epic', benefit: 'allBoost', value: 1.4 },
            { name: 'Phoenix', rarity: 'Mythic', benefit: 'autoHarvest', value: 1.5 }
        ];
        let ownedPets = [];
        let equippedPets = [];
        
        function spinPetWheel() {
            if (tokens < 10) {
                alertInGame('Not enough tokens to spin the wheel! Earn more by playing mini-games.');
                return;
            }
            tokens -= 10;
            updateTokens();
            petSound.play();
            const pet = availablePets[Math.floor(Math.random() * availablePets.length)];
            ownedPets.push(pet);
            alertInGame(`You received a ${pet.rarity} Pet: ${pet.name}!`);
            renderOwnedPets();
            checkQuests(null, 'minigame');
            checkAchievements(null, 'minigame');
        }
        
        function renderOwnedPets() {
            const container = document.getElementById('pets-container');
            container.innerHTML = '';
            ownedPets.forEach((pet, index) => {
                let petDiv = document.createElement('div');
                petDiv.classList.add('pet', 'pet-owned');
                petDiv.innerHTML = `
                    <div class="emoji">${getPetEmoji(pet.name)}</div>
                    <h3>${pet.name} (${pet.rarity})</h3>
                    <p>Benefit: ${getBenefitDescription(pet.benefit)}</p>
                    <button onclick="equipPet(${index})" style="margin-top:10px; padding:5px 10px; cursor:pointer;">Equip</button>
                `;
                container.appendChild(petDiv);
            });
        }
        
        function getPetEmoji(name) {
            const map = {
                'Pup': 'üê∂',
                'Kitty': 'üê±',
                'Dragon': 'üêâ',
                'Unicorn': 'ü¶Ñ',
                'Phoenix': 'üî•'
            };
            return map[name] || 'üêæ';
        }
        
        function getBenefitDescription(benefit) {
            const map = {
                'moneyBoost': 'Increase coin earnings by 10%',
                'timeBoost': 'Decrease growth times by 10%',
                'coinMultiplier': 'Increase coin multiplier by 10%',
                'allBoost': 'Increase all earnings by 10%',
                'autoHarvest': 'Automatically harvest crops every 60s'
            };
            return map[benefit] || 'No benefit';
        }
        
        function equipPet(index) {
            if (equippedPets.length >= 2) {
                alertInGame('You can only equip 2 pets at a time.');
                return;
            }
            const pet = ownedPets[index];
            equippedPets.push(pet);
            alertInGame(`${pet.name} equipped! Benefits applied.`);
            applyPetBenefits();
            renderOwnedPets();
        }
        
        function applyPetBenefits() {
            equippedPets.forEach(pet => {
                switch(pet.benefit) {
                    case 'moneyBoost':
                        coinMultiplier *= pet.value;
                        break;
                    case 'timeBoost':
                        for (let crop in growthTimes) {
                            growthTimes[crop] = Math.max(1, growthTimes[crop] / pet.value);
                        }
                        break;
                    case 'coinMultiplier':
                        coinMultiplier *= pet.value;
                        break;
                    case 'allBoost':
                        coinMultiplier *= pet.value;
                        // Apply other benefits if needed
                        break;
                    case 'autoHarvest':
                        // Implement auto-harvest functionality
                        // Example: setInterval to auto-harvest crops
                        setInterval(() => {
                            for (let crop in baseRewards) {
                                coins += baseRewards[crop] * coinMultiplier;
                                playerNetWorth += baseRewards[crop] * coinMultiplier;
                            }
                            updateCoins();
                            alertInGame('Auto-harvested all crops! +10 coins.');
                        }, 60000); // Every 60 seconds
                        break;
                    default:
                        break;
                }
            });
        }
        
        function getOwnedPets() {
            return ownedPets;
        }
        
        // Black Market Rendering
        function generateBlackMarketItems() {
            const baseAnimals = ['üê∂', 'üê±', 'ü¶ä', 'üê∞', 'üêª'];
            const rarities = ['Common', 'Uncommon', 'Rare', 'Epic', 'Mythic'];
            blackMarketItems = [];
            baseAnimals.forEach(animal => {
                rarities.forEach(rarity => {
                    let cost = 100;
                    switch(rarity) {
                        case 'Common':
                            cost = 100;
                            break;
                        case 'Uncommon':
                            cost = 300;
                            break;
                        case 'Rare':
                            cost = 600;
                            break;
                        case 'Epic':
                            cost = 1000;
                            break;
                        case 'Mythic':
                            cost = 2000;
                            break;
                    }
                    blackMarketItems.push({
                        animal: animal,
                        rarity: rarity,
                        cost: cost,
                        benefits: getBenefitsByRarity(rarity)
                    });
                });
            });
        }
        
        function getBenefitsByRarity(rarity) {
            switch(rarity) {
                case 'Common':
                    return { coinBoost: 1 };
                case 'Uncommon':
                    return { coinBoost: 1.5 };
                case 'Rare':
                    return { coinBoost: 2 };
                case 'Epic':
                    return { coinBoost: 3 };
                case 'Mythic':
                    return { coinBoost: 5 };
                default:
                    return { coinBoost: 1 };
            }
        }
        
        function renderBlackMarket() {
            generateBlackMarketItems();
            const container = document.getElementById('blackmarket-container');
            container.innerHTML = '';
            blackMarketItems.forEach((item, index) => {
                let itemDiv = document.createElement('div');
                itemDiv.classList.add('blackmarket');
                itemDiv.innerHTML = `
                    <div class="emoji">${item.animal}</div>
                    <h3>${item.rarity} Animal</h3>
                    <p>Cost: ${item.cost} coins</p>
                    <button onclick="buyBlackMarketItem(${index})" style="margin-top:10px; padding:5px 10px; cursor:pointer;">Buy</button>
                `;
                container.appendChild(itemDiv);
            });
        }
        
        function buyBlackMarketItem(index) {
            const item = blackMarketItems[index];
            if (coins >= item.cost) {
                coins -= item.cost;
                tokens += 1; // Reward token for purchase
                playerNetWorth += item.cost;
                alertInGame(`Purchased ${item.rarity} Animal ${item.animal}! +${item.benefits.coinBoost}x coins from this animal.`);
                upgradeSound.play();
                addBlackMarketAnimal(item);
                updateCoins();
                updateTokens();
                checkAchievements(null, null);
            } else {
                alertInGame('Not enough coins!');
            }
        }
        
        function addBlackMarketAnimal(item) {
            // Add to animal section with benefits
            const animalContainer = document.getElementById('animals-container');
            let existingAnimal = document.getElementById(item.animal + 'Special');
            if (existingAnimal) {
                // If already exists, increment count
                let countSpan = existingAnimal.querySelector('.count');
                let currentCount = parseInt(countSpan.innerText);
                countSpan.innerText = currentCount + 1;
                // Update benefits if necessary
            } else {
                // Create new animal with benefits
                let animalName = getAnimalName(item.animal) + 'Special';
                let newAnimal = document.createElement('div');
                newAnimal.classList.add('animal');
                newAnimal.id = animalName;
                newAnimal.innerHTML = `
                    <div class="emoji">${item.animal}</div>
                    <h3>${getAnimalName(item.animal)} (${item.rarity})</h3>
                    <p>Coin Boost: x${item.benefits.coinBoost}</p>
                    <p>Owned: <span class="count">1</span></p>
                    <button onclick="buyMoreSpecial('${animalName}', ${item.cost})" style="margin-top:10px; padding:5px 10px; cursor:pointer;">Buy More</button>
                `;
                animalContainer.appendChild(newAnimal);
            }
        }
        
        function buyMoreSpecial(animalId, baseCost) {
            let countSpan = document.getElementById(animalId).querySelector('.count');
            let count = parseInt(countSpan.innerText);
            let cost = baseCost * Math.pow(1.5, count); // Increasing cost
            if (coins >= cost) {
                coins -= cost;
                countSpan.innerText = count + 1;
                tokens += 1; // Reward token for purchase
                playerNetWorth += cost;
                alertInGame(`Purchased another ${getAnimalName(animalId.replace('Special',''))}! +${baseRewards[getAnimalName(animalId.replace('Special',''))]} coins.`);
                upgradeSound.play();
                updateCoins();
                updateTokens();
                checkAchievements(null, null);
            } else {
                alertInGame('Not enough coins!');
            }
        }
        
        // NPC Trading System
        function generateNPCs() {
            const names = ['Woody', 'Lily', 'Max', 'Bella', 'Charlie', 'Daisy', 'Rocky', 'Molly', 'Buddy', 'Lucy', 'Jack', 'Luna', 'Oliver', 'Chloe', 'Toby'];
            const categories = ['Bronze', 'Silver', 'Gold', 'Platinum', 'Diamond'];
            let npcList = [];
            categories.forEach((category, catIndex) => {
                for (let i = 0; i < 3; i++) {
                    npcList.push({
                        name: names[catIndex * 3 + i],
                        category: category,
                        contactChance: catIndex + 1, // Higher category, higher chance
                        offeredAnimal: getRandomMythicAnimal(category),
                        pet: getRandomPet(category)
                    });
                }
            });
            return npcList;
        }
        
        function getRandomMythicAnimal(category) {
            const mythicAnimals = {
                'Bronze': 'ü¶Å', // Example
                'Silver': 'üêâ',
                'Gold': 'ü¶Ñ',
                'Platinum': 'üê≤',
                'Diamond': 'üê∫'
            };
            return mythicAnimals[category] || 'ü¶ä';
        }
        
        function getRandomPet(category) {
            const pets = {
                'Bronze': { name: 'Pup', rarity: 'Common', benefit: 'moneyBoost', value: 1.1 },
                'Silver': { name: 'Kitty', rarity: 'Uncommon', benefit: 'timeBoost', value: 1.2 },
                'Gold': { name: 'Dragon', rarity: 'Rare', benefit: 'coinMultiplier', value: 1.3 },
                'Platinum': { name: 'Unicorn', rarity: 'Epic', benefit: 'allBoost', value: 1.4 },
                'Diamond': { name: 'Phoenix', rarity: 'Mythic', benefit: 'autoHarvest', value: 1.5 }
            };
            return pets[category] || { name: 'Pet', rarity: 'Common', benefit: 'none', value: 1 };
        }
        
        function renderNPCs() {
            // NPC rendering can be implemented if a specific UI is desired
        }
        
        function startNPCAutoContact() {
            setInterval(() => {
                const chance = Math.random() * 100;
                const threshold = calculateNPCCallThreshold();
                if (chance < threshold) {
                    contactNPC();
                }
            }, 300000); // Every 5 minutes
        }
        
        function calculateNPCCallThreshold() {
            // Higher net worth increases the chance
            // Example: 1% per 1000 coins
            return Math.min(playerNetWorth / 1000, 20); // Max 20% chance
        }
        
        function contactNPC() {
            const filteredNPCs = npcs.filter(npc => Math.random() < (npc.contactChance / 10));
            if (filteredNPCs.length === 0) return;
            const npc = filteredNPCs[Math.floor(Math.random() * filteredNPCs.length)];
            const accept = confirm(`${npc.name} from ${npc.category} category wants to trade! Accept?`);
            if (accept) {
                tokens += 5;
                coins += 500 * coinMultiplier; // Example trade deal
                playerNetWorth += 500 * coinMultiplier;
                alertInGame(`Trade accepted with ${npc.name}! +${500 * coinMultiplier} coins and +5 tokens.`);
                checkQuests(null, 'npc');
                checkAchievements(null, 'npc');
            } else {
                alertInGame(`Trade with ${npc.name} declined.`);
            }
        }
        
        // Pets System
        let availablePets = [
            { name: 'Pup', rarity: 'Common', benefit: 'moneyBoost', value: 1.1 },
            { name: 'Kitty', rarity: 'Uncommon', benefit: 'timeBoost', value: 1.2 },
            { name: 'Dragon', rarity: 'Rare', benefit: 'coinMultiplier', value: 1.3 },
            { name: 'Unicorn', rarity: 'Epic', benefit: 'allBoost', value: 1.4 },
            { name: 'Phoenix', rarity: 'Mythic', benefit: 'autoHarvest', value: 1.5 }
        ];
        let ownedPets = [];
        let equippedPets = [];
        
        function spinPetWheel() {
            if (tokens < 10) {
                alertInGame('Not enough tokens to spin the wheel! Earn more by playing mini-games.');
                return;
            }
            tokens -= 10;
            updateTokens();
            petSound.play();
            const pet = availablePets[Math.floor(Math.random() * availablePets.length)];
            ownedPets.push(pet);
            alertInGame(`You received a ${pet.rarity} Pet: ${pet.name}!`);
            renderOwnedPets();
            checkQuests(null, 'minigame');
            checkAchievements(null, 'minigame');
        }
        
        function renderOwnedPets() {
            const container = document.getElementById('pets-container');
            container.innerHTML = '';
            ownedPets.forEach((pet, index) => {
                let petDiv = document.createElement('div');
                petDiv.classList.add('pet', 'pet-owned');
                petDiv.innerHTML = `
                    <div class="emoji">${getPetEmoji(pet.name)}</div>
                    <h3>${pet.name} (${pet.rarity})</h3>
                    <p>Benefit: ${getBenefitDescription(pet.benefit)}</p>
                    <button onclick="equipPet(${index})" style="margin-top:10px; padding:5px 10px; cursor:pointer;">Equip</button>
                `;
                container.appendChild(petDiv);
            });
        }
        
        function getPetEmoji(name) {
            const map = {
                'Pup': 'üê∂',
                'Kitty': 'üê±',
                'Dragon': 'üêâ',
                'Unicorn': 'ü¶Ñ',
                'Phoenix': 'üî•'
            };
            return map[name] || 'üêæ';
        }
        
        function getBenefitDescription(benefit) {
            const map = {
                'moneyBoost': 'Increase coin earnings by 10%',
                'timeBoost': 'Decrease growth times by 10%',
                'coinMultiplier': 'Increase coin multiplier by 10%',
                'allBoost': 'Increase all earnings by 10%',
                'autoHarvest': 'Automatically harvest crops every 60s'
            };
            return map[benefit] || 'No benefit';
        }
        
        function equipPet(index) {
            if (equippedPets.length >= 2) {
                alertInGame('You can only equip 2 pets at a time.');
                return;
            }
            const pet = ownedPets[index];
            equippedPets.push(pet);
            alertInGame(`${pet.name} equipped! Benefits applied.`);
            applyPetBenefits();
            renderOwnedPets();
        }
        
        function applyPetBenefits() {
            equippedPets.forEach(pet => {
                switch(pet.benefit) {
                    case 'moneyBoost':
                        coinMultiplier *= pet.value;
                        break;
                    case 'timeBoost':
                        for (let crop in growthTimes) {
                            growthTimes[crop] = Math.max(1, growthTimes[crop] / pet.value);
                        }
                        break;
                    case 'coinMultiplier':
                        coinMultiplier *= pet.value;
                        break;
                    case 'allBoost':
                        coinMultiplier *= pet.value;
                        // Apply other benefits if needed
                        break;
                    case 'autoHarvest':
                        // Implement auto-harvest functionality
                        // Example: setInterval to auto-harvest crops
                        setInterval(() => {
                            for (let crop in baseRewards) {
                                coins += baseRewards[crop] * coinMultiplier;
                                playerNetWorth += baseRewards[crop] * coinMultiplier;
                            }
                            updateCoins();
                            alertInGame('Auto-harvested all crops! +10 coins.');
                        }, 60000); // Every 60 seconds
                        break;
                    default:
                        break;
                }
            });
        }
        
        function getOwnedPets() {
            return ownedPets;
        }
        
        // Black Market Rendering
        function generateBlackMarketItems() {
            const baseAnimals = ['üê∂', 'üê±', 'ü¶ä', 'üê∞', 'üêª'];
            const rarities = ['Common', 'Uncommon', 'Rare', 'Epic', 'Mythic'];
            blackMarketItems = [];
            baseAnimals.forEach(animal => {
                rarities.forEach(rarity => {
                    let cost = 100;
                    switch(rarity) {
                        case 'Common':
                            cost = 100;
                            break;
                        case 'Uncommon':
                            cost = 300;
                            break;
                        case 'Rare':
                            cost = 600;
                            break;
                        case 'Epic':
                            cost = 1000;
                            break;
                        case 'Mythic':
                            cost = 2000;
                            break;
                    }
                    blackMarketItems.push({
                        animal: animal,
                        rarity: rarity,
                        cost: cost,
                        benefits: getBenefitsByRarity(rarity)
                    });
                });
            });
        }
        
        function getBenefitsByRarity(rarity) {
            switch(rarity) {
                case 'Common':
                    return { coinBoost: 1 };
                case 'Uncommon':
                    return { coinBoost: 1.5 };
                case 'Rare':
                    return { coinBoost: 2 };
                case 'Epic':
                    return { coinBoost: 3 };
                case 'Mythic':
                    return { coinBoost: 5 };
                default:
                    return { coinBoost: 1 };
            }
        }
        
        function renderBlackMarket() {
            generateBlackMarketItems();
            const container = document.getElementById('blackmarket-container');
            container.innerHTML = '';
            blackMarketItems.forEach((item, index) => {
                let itemDiv = document.createElement('div');
                itemDiv.classList.add('blackmarket');
                itemDiv.innerHTML = `
                    <div class="emoji">${item.animal}</div>
                    <h3>${item.rarity} Animal</h3>
                    <p>Cost: ${item.cost} coins</p>
                    <button onclick="buyBlackMarketItem(${index})" style="margin-top:10px; padding:5px 10px; cursor:pointer;">Buy</button>
                `;
                container.appendChild(itemDiv);
            });
        }
        
        function buyBlackMarketItem(index) {
            const item = blackMarketItems[index];
            if (coins >= item.cost) {
                coins -= item.cost;
                tokens += 1; // Reward token for purchase
                playerNetWorth += item.cost;
                alertInGame(`Purchased ${item.rarity} Animal ${item.animal}! +${item.benefits.coinBoost}x coins from this animal.`);
                upgradeSound.play();
                addBlackMarketAnimal(item);
                updateCoins();
                updateTokens();
                checkAchievements(null, null);
            } else {
                alertInGame('Not enough coins!');
            }
        }
        
        function addBlackMarketAnimal(item) {
            // Add to animal section with benefits
            const animalContainer = document.getElementById('animals-container');
            let existingAnimal = document.getElementById(item.animal + 'Special');
            if (existingAnimal) {
                // If already exists, increment count
                let countSpan = existingAnimal.querySelector('.count');
                let currentCount = parseInt(countSpan.innerText);
                countSpan.innerText = currentCount + 1;
                // Update benefits if necessary
            } else {
                // Create new animal with benefits
                let animalName = getAnimalName(item.animal) + 'Special';
                let newAnimal = document.createElement('div');
                newAnimal.classList.add('animal');
                newAnimal.id = animalName;
                newAnimal.innerHTML = `
                    <div class="emoji">${item.animal}</div>
                    <h3>${getAnimalName(item.animal)} (${item.rarity})</h3>
                    <p>Coin Boost: x${item.benefits.coinBoost}</p>
                    <p>Owned: <span class="count">1</span></p>
                    <button onclick="buyMoreSpecial('${animalName}', ${item.cost})" style="margin-top:10px; padding:5px 10px; cursor:pointer;">Buy More</button>
                `;
                animalContainer.appendChild(newAnimal);
            }
        }
        
        function buyMoreSpecial(animalId, baseCost) {
            let countSpan = document.getElementById(animalId).querySelector('.count');
            let count = parseInt(countSpan.innerText);
            let cost = baseCost * Math.pow(1.5, count); // Increasing cost
            if (coins >= cost) {
                coins -= cost;
                countSpan.innerText = count + 1;
                tokens += 1; // Reward token for purchase
                playerNetWorth += cost;
                alertInGame(`Purchased another ${getAnimalName(animalId.replace('Special',''))}! +${baseRewards[getAnimalName(animalId.replace('Special',''))]} coins.`);
                upgradeSound.play();
                updateCoins();
                updateTokens();
                checkAchievements(null, null);
            } else {
                alertInGame('Not enough coins!');
            }
        }
        
        // NPC Trading System
        function generateNPCs() {
            const names = ['Woody', 'Lily', 'Max', 'Bella', 'Charlie', 'Daisy', 'Rocky', 'Molly', 'Buddy', 'Lucy', 'Jack', 'Luna', 'Oliver', 'Chloe', 'Toby'];
            const categories = ['Bronze', 'Silver', 'Gold', 'Platinum', 'Diamond'];
            let npcList = [];
            categories.forEach((category, catIndex) => {
                for (let i = 0; i < 3; i++) {
                    npcList.push({
                        name: names[catIndex * 3 + i],
                        category: category,
                        contactChance: catIndex + 1, // Higher category, higher chance
                        offeredAnimal: getRandomMythicAnimal(category),
                        pet: getRandomPet(category)
                    });
                }
            });
            return npcList;
        }
        
        function getRandomMythicAnimal(category) {
            const mythicAnimals = {
                'Bronze': 'ü¶Å', // Example
                'Silver': 'üêâ',
                'Gold': 'ü¶Ñ',
                'Platinum': 'üê≤',
                'Diamond': 'üê∫'
            };
            return mythicAnimals[category] || 'ü¶ä';
        }
        
        function getRandomPet(category) {
            const pets = {
                'Bronze': { name: 'Pup', rarity: 'Common', benefit: 'moneyBoost', value: 1.1 },
                'Silver': { name: 'Kitty', rarity: 'Uncommon', benefit: 'timeBoost', value: 1.2 },
                'Gold': { name: 'Dragon', rarity: 'Rare', benefit: 'coinMultiplier', value: 1.3 },
                'Platinum': { name: 'Unicorn', rarity: 'Epic', benefit: 'allBoost', value: 1.4 },
                'Diamond': { name: 'Phoenix', rarity: 'Mythic', benefit: 'autoHarvest', value: 1.5 }
            };
            return pets[category] || { name: 'Pet', rarity: 'Common', benefit: 'none', value: 1 };
        }
        
        function renderNPCs() {
            // NPC rendering can be implemented if a specific UI is desired
        }
        
        function startNPCAutoContact() {
            setInterval(() => {
                const chance = Math.random() * 100;
                const threshold = calculateNPCCallThreshold();
                if (chance < threshold) {
                    contactNPC();
                }
            }, 300000); // Every 5 minutes
        }
        
        function calculateNPCCallThreshold() {
            // Higher net worth increases the chance
            // Example: 1% per 1000 coins
            return Math.min(playerNetWorth / 1000, 20); // Max 20% chance
        }
        
        function contactNPC() {
            const filteredNPCs = npcs.filter(npc => Math.random() < (npc.contactChance / 10));
            if (filteredNPCs.length === 0) return;
            const npc = filteredNPCs[Math.floor(Math.random() * filteredNPCs.length)];
            const accept = confirm(`${npc.name} from ${npc.category} category wants to trade! Accept?`);
            if (accept) {
                tokens += 5;
                coins += 500 * coinMultiplier; // Example trade deal
                playerNetWorth += 500 * coinMultiplier;
                alertInGame(`Trade accepted with ${npc.name}! +${500 * coinMultiplier} coins and +5 tokens.`);
                checkQuests(null, 'npc');
                checkAchievements(null, 'npc');
            } else {
                alertInGame(`Trade with ${npc.name} declined.`);
            }
        }
        
        // Pets System
        let availablePets = [
            { name: 'Pup', rarity: 'Common', benefit: 'moneyBoost', value: 1.1 },
            { name: 'Kitty', rarity: 'Uncommon', benefit: 'timeBoost', value: 1.2 },
            { name: 'Dragon', rarity: 'Rare', benefit: 'coinMultiplier', value: 1.3 },
            { name: 'Unicorn', rarity: 'Epic', benefit: 'allBoost', value: 1.4 },
            { name: 'Phoenix', rarity: 'Mythic', benefit: 'autoHarvest', value: 1.5 }
        ];
        let ownedPets = [];
        let equippedPets = [];
        
        function spinPetWheel() {
            if (tokens < 10) {
                alertInGame('Not enough tokens to spin the wheel! Earn more by playing mini-games.');
                return;
            }
            tokens -= 10;
            updateTokens();
            petSound.play();
            const pet = availablePets[Math.floor(Math.random() * availablePets.length)];
            ownedPets.push(pet);
            alertInGame(`You received a ${pet.rarity} Pet: ${pet.name}!`);
            renderOwnedPets();
            checkQuests(null, 'minigame');
            checkAchievements(null, 'minigame');
        }
        
        function renderOwnedPets() {
            const container = document.getElementById('pets-container');
            container.innerHTML = '';
            ownedPets.forEach((pet, index) => {
                let petDiv = document.createElement('div');
                petDiv.classList.add('pet', 'pet-owned');
                petDiv.innerHTML = `
                    <div class="emoji">${getPetEmoji(pet.name)}</div>
                    <h3>${pet.name} (${pet.rarity})</h3>
                    <p>Benefit: ${getBenefitDescription(pet.benefit)}</p>
                    <button onclick="equipPet(${index})" style="margin-top:10px; padding:5px 10px; cursor:pointer;">Equip</button>
                `;
                container.appendChild(petDiv);
            });
        }
        
        function getPetEmoji(name) {
            const map = {
                'Pup': 'üê∂',
                'Kitty': 'üê±',
                'Dragon': 'üêâ',
                'Unicorn': 'ü¶Ñ',
                'Phoenix': 'üî•'
            };
            return map[name] || 'üêæ';
        }
        
        function getBenefitDescription(benefit) {
            const map = {
                'moneyBoost': 'Increase coin earnings by 10%',
                'timeBoost': 'Decrease growth times by 10%',
                'coinMultiplier': 'Increase coin multiplier by 10%',
                'allBoost': 'Increase all earnings by 10%',
                'autoHarvest': 'Automatically harvest crops every 60s'
            };
            return map[benefit] || 'No benefit';
        }
        
        function equipPet(index) {
            if (equippedPets.length >= 2) {
                alertInGame('You can only equip 2 pets at a time.');
                return;
            }
            const pet = ownedPets[index];
            equippedPets.push(pet);
            alertInGame(`${pet.name} equipped! Benefits applied.`);
            applyPetBenefits();
            renderOwnedPets();
        }
        
        function applyPetBenefits() {
            equippedPets.forEach(pet => {
                switch(pet.benefit) {
                    case 'moneyBoost':
                        coinMultiplier *= pet.value;
                        break;
                    case 'timeBoost':
                        for (let crop in growthTimes) {
                            growthTimes[crop] = Math.max(1, growthTimes[crop] / pet.value);
                        }
                        break;
                    case 'coinMultiplier':
                        coinMultiplier *= pet.value;
                        break;
                    case 'allBoost':
                        coinMultiplier *= pet.value;
                        // Apply other benefits if needed
                        break;
                    case 'autoHarvest':
                        // Implement auto-harvest functionality
                        // Example: setInterval to auto-harvest crops
                        setInterval(() => {
                            for (let crop in baseRewards) {
                                coins += baseRewards[crop] * coinMultiplier;
                                playerNetWorth += baseRewards[crop] * coinMultiplier;
                            }
                            updateCoins();
                            alertInGame('Auto-harvested all crops! +10 coins.');
                        }, 60000); // Every 60 seconds
                        break;
                    default:
                        break;
                }
            });
        }
        
        // Mini Games System
        let miniGameCount = 0;
        function openMiniGame(gameName) {
            // Open the mini-game in an iframe or popup
            if (gameName === 'flappyBird') {
                // For simplicity, we'll simulate a mini-game
                playFlappyBird();
            }
            // Additional mini-games can be handled here
        }
        
        function closeMiniGame() {
            const container = document.getElementById('miniGameContainer');
            container.style.display = 'none';
            document.getElementById('miniGameFrame').src = '';
        }
        
        function playFlappyBird() {
            // Simple Flappy Bird-like game implementation
            // For brevity, this is a placeholder. You can integrate an actual mini-game or create a simple version.
            let gameWindow = window.open('', 'Flappy Bird', 'width=400,height=600');
            gameWindow.document.write(`
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <title>Flappy Farm</title>
                    <style>
                        body { margin: 0; overflow: hidden; background: skyblue; }
                        canvas { display: block; }
                    </style>
                </head>
                <body>
                    <canvas id="flappyCanvas" width="400" height="600"></canvas>
                    <script>
                        const canvas = document.getElementById('flappyCanvas');
                        const ctx = canvas.getContext('2d');
                        let frames = 0;
                        const DEGREE = Math.PI/180;
                        
                        const sprite = new Image();
                        sprite.src = 'https://www.pngall.com/wp-content/uploads/5/Flappy-Bird-PNG-Download-Image.png';
                        
                        // Game State
                        const state = {
                            current: 0,
                            getReady: 0,
                            game: 1,
                            over: 2
                        };
                        
                        // Start button coordinates
                        const startBtn = {
                            x: 120,
                            y: 263,
                            w: 83,
                            h: 29
                        };
                        
                        // Control the game
                        canvas.addEventListener("click", function(evt){
                            switch(state.current){
                                case state.getReady:
                                    state.current = state.game;
                                    break;
                                case state.game:
                                    bird.flap();
                                    break;
                                case state.over:
                                    let rect = canvas.getBoundingClientRect();
                                    let clickX = evt.clientX - rect.left;
                                    let clickY = evt.clientY - rect.top;
                                    
                                    // Check if we click on the start button
                                    if(clickX >= startBtn.x && clickX <= startBtn.x + startBtn.w && clickY >= startBtn.y && clickY <= startBtn.y + startBtn.h){
                                        pipes.reset();
                                        bird.speedReset();
                                        score.reset();
                                        state.current = state.getReady;
                                    }
                                    break;
                            }
                        });
                        
                        // Bird
                        const bird = {
                            animation: [
                                {sX: 276, sY: 112},
                                {sX: 276, sY: 139},
                                {sX: 276, sY: 164},
                                {sX: 276, sY: 139}
                            ],
                            x: 50,
                            y: 150,
                            w: 34,
                            h: 26,
                            frame: 0,
                            gravity: 0.25,
                            jump: 4.6,
                            speed: 0,
                            rotation: 0,
                            
                            draw: function(){
                                let bird = this.animation[this.frame];
                                
                                ctx.save();
                                ctx.translate(this.x, this.y);
                                ctx.rotate(this.rotation);
                                ctx.drawImage(sprite, bird.sX, bird.sY, this.w, this.h, - this.w/2, - this.h/2, this.w, this.h);
                                
                                ctx.restore();
                            },
                            
                            flap: function(){
                                this.speed = - this.jump;
                            },
                            
                            update: function(){
                                // If the game state is get ready, the bird doesn't fall down
                                this.period = state.current == state.game ? 5 : 10;
                                this.frame += frames % this.period == 0 ? 1 : 0;
                                this.frame = this.frame % this.animation.length;
                                
                                if(state.current == state.getReady){
                                    this.y = 150; // Reset position
                                    this.rotation = 0 * DEGREE;
                                } else {
                                    this.speed += this.gravity;
                                    this.y += this.speed;
                                    
                                    if(this.y + this.h/2 >= canvas.height - 112){
                                        this.y = canvas.height - 112 - this.h/2;
                                        if(state.current == state.game){
                                            state.current = state.over;
                                        }
                                    }
                                    
                                    // If the speed is greater than the jump, the bird is falling down
                                    if(this.speed >= this.jump){
                                        this.rotation = 90 * DEGREE;
                                        this.frame = 1; // Frame when falling
                                    } else {
                                        this.rotation = -25 * DEGREE;
                                    }
                                }
                            },
                            
                            speedReset: function(){
                                this.speed = 0;
                            }
                        };
                        
                        // Pipes
                        const pipes = {
                            position: [],
                            top: {
                                sX: 553, sY: 0
                            },
                            bottom: {
                                sX: 502, sY: 0
                            },
                            w: 53,
                            h: 400,
                            gap: 85,
                            maxYPos: -150,
                            dx: 2,
                            
                            draw: function(){
                                for(let i = 0; i < this.position.length; i++){
                                    let p = this.position[i];
                                    
                                    let topYPos = p.y;
                                    let bottomYPos = p.y + this.h + this.gap;
                                    
                                    // top pipe
                                    ctx.drawImage(sprite, this.top.sX, this.top.sY, this.w, this.h, p.x, topYPos, this.w, this.h);  
                                    
                                    // bottom pipe
                                    ctx.drawImage(sprite, this.bottom.sX, this.bottom.sY, this.w, this.h, p.x, bottomYPos, this.w, this.h);
                                }
                            },
                            
                            update: function(){
                                if(state.current !== state.game) return;
                                
                                if(frames % 100 == 0){
                                    this.position.push({
                                        x: canvas.width,
                                        y: this.maxYPos * (Math.random() + 1)
                                    });
                                }
                                for(let i = 0; i < this.position.length; i++){
                                    let p = this.position[i];
                                    
                                    p.x -= this.dx;
                                    
                                    // Collision detection
                                    // Top pipe
                                    if(bird.x + bird.w/2 > p.x && bird.x - bird.w/2 < p.x + this.w &&
                                        bird.y - bird.h/2 < p.y + this.h){
                                            state.current = state.over;
                                    }
                                    
                                    // Bottom pipe
                                    if(bird.x + bird.w/2 > p.x && bird.x - bird.w/2 < p.x + this.w &&
                                        bird.y + bird.h/2 > p.y + this.h + this.gap){
                                            state.current = state.over;
                                    }
                                    
                                    // Remove pipes when off screen
                                    if(p.x + this.w <= 0){
                                        this.position.shift();
                                        score.value += 1;
                                        score.best = Math.max(score.best, score.value);
                                        score.draw();
                                    }
                                }
                            },
                            
                            reset: function(){
                                this.position = [];
                            }
                        };
        
        // Score
        const score = {
            best: parseInt(localStorage.getItem("best")) || 0,
            value: 0,
        
            draw: function(){
                ctx.fillStyle = "#FFF";
                ctx.strokeStyle = "#000";
        
                if(state.current == state.game){
                    ctx.lineWidth = 2;
                    ctx.font = "35px Teko";
                    ctx.fillText(this.value, canvas.width/2, 50);
                    ctx.strokeText(this.value, canvas.width/2, 50);
                } else if(state.current == state.over){
                    // SCORE VALUE
                    ctx.font = "25px Teko";
                    ctx.fillText(this.value, 225, 186);
                    ctx.strokeText(this.value, 225, 186);
                    // BEST SCORE
                    ctx.fillText(this.best, 225, 228);
                    ctx.strokeText(this.best, 225, 228);
                }
            },
        
            reset: function(){
                this.value = 0;
            }
        };
        
        // Game Loop
        function loop(){
            update();
            draw();
            frames++;
            requestAnimationFrame(loop);
        }
        
        function update(){
            bird.update();
            pipes.update();
            score.update();
        }
        
        function draw(){
            ctx.fillStyle = "#70c5ce";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        
            pipes.draw();
            bird.draw();
            score.draw();
        }
        
        loop();
        
        // Mini Games Implementation
        function playFlappyBird() {
            // Placeholder for Flappy Bird-like mini-game
            // For a real implementation, embed an existing mini-game or create a simple version
            // Here, we'll simulate a mini-game with a simple timer
            let gameWindow = window.open('', 'Flappy Bird', 'width=400,height=600');
            gameWindow.document.write(`
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <title>Flappy Farm</title>
                    <style>
                        body { margin: 0; overflow: hidden; background: skyblue; }
                        canvas { display: block; }
                    </style>
                </head>
                <body>
                    <canvas id="flappyCanvas" width="400" height="600"></canvas>
                    <script>
                        const canvas = document.getElementById('flappyCanvas');
                        const ctx = canvas.getContext('2d');
                        let gameOver = false;
                        let score = 0;
                        const startTime = Date.now();
                        
                        // Simple game loop
                        function draw() {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            ctx.fillStyle = 'black';
                            ctx.font = '30px Arial';
                            ctx.fillText('Flappy Farm', 100, 100);
                            ctx.fillText('Press Space to "Flap"', 50, 150);
                        }
        
                        function gameLoop() {
                            if (gameOver) return;
                            draw();
                            // Simple timer-based scoring
                            score = Math.floor((Date.now() - startTime) / 1000);
                            ctx.fillText('Score: ' + score, 150, 200);
                            requestAnimationFrame(gameLoop);
                        }
        
                        window.addEventListener('keydown', function(e){
                            if(e.code === 'Space'){
                                alert('You flapped! Keep going...');
                            }
                        });
        
                        gameLoop();
                    </script>
                </body>
                </html>
            `);
        
            // After a certain time, close the mini-game and reward tokens
            setTimeout(() => {
                gameWindow.close();
                tokens += 2;
                tokenSound.play();
                alertInGame('Mini-Game Completed! +2 Tokens.');
                updateTokens();
                checkQuests(null, 'minigame');
                checkAchievements(null, 'minigame');
            }, 15000); // 15 seconds simulation
        }
        
        // Black Market System
        let blackMarketItems = [];
        function generateBlackMarketItems() {
            const baseAnimals = ['üê∂', 'üê±', 'ü¶ä', 'üê∞', 'üêª'];
            const rarities = ['Common', 'Uncommon', 'Rare', 'Epic', 'Mythic'];
            blackMarketItems = [];
            baseAnimals.forEach(animal => {
                rarities.forEach(rarity => {
                    let cost = 100;
                    switch(rarity) {
                        case 'Common':
                            cost = 100;
                            break;
                        case 'Uncommon':
                            cost = 300;
                            break;
                        case 'Rare':
                            cost = 600;
                            break;
                        case 'Epic':
                            cost = 1000;
                            break;
                        case 'Mythic':
                            cost = 2000;
                            break;
                    }
                    blackMarketItems.push({
                        animal: animal,
                        rarity: rarity,
                        cost: cost,
                        benefits: getBenefitsByRarity(rarity)
                    });
                });
            });
        }
        
        function getBenefitsByRarity(rarity) {
            switch(rarity) {
                case 'Common':
                    return { coinBoost: 1 };
                case 'Uncommon':
                    return { coinBoost: 1.5 };
                case 'Rare':
                    return { coinBoost: 2 };
                case 'Epic':
                    return { coinBoost: 3 };
                case 'Mythic':
                    return { coinBoost: 5 };
                default:
                    return { coinBoost: 1 };
            }
        }
        
        function renderBlackMarket() {
            generateBlackMarketItems();
            const container = document.getElementById('blackmarket-container');
            container.innerHTML = '';
            blackMarketItems.forEach((item, index) => {
                let itemDiv = document.createElement('div');
                itemDiv.classList.add('blackmarket');
                itemDiv.innerHTML = `
                    <div class="emoji">${item.animal}</div>
                    <h3>${item.rarity} Animal</h3>
                    <p>Cost: ${item.cost} coins</p>
                    <button onclick="buyBlackMarketItem(${index})" style="margin-top:10px; padding:5px 10px; cursor:pointer;">Buy</button>
                `;
                container.appendChild(itemDiv);
            });
        }
        
        function buyBlackMarketItem(index) {
            const item = blackMarketItems[index];
            if (coins >= item.cost) {
                coins -= item.cost;
                tokens += 1; // Reward token for purchase
                playerNetWorth += item.cost;
                alertInGame(`Purchased ${item.rarity} Animal ${item.animal}! +${item.benefits.coinBoost}x coins from this animal.`);
                upgradeSound.play();
                addBlackMarketAnimal(item);
                updateCoins();
                updateTokens();
                checkAchievements(null, null);
            } else {
                alertInGame('Not enough coins!');
            }
        }
        
        function addBlackMarketAnimal(item) {
            // Add to animal section with benefits
            const animalContainer = document.getElementById('animals-container');
            let existingAnimal = document.getElementById(getAnimalName(item.animal) + 'Special');
            if (existingAnimal) {
                // If already exists, increment count
                let countSpan = existingAnimal.querySelector('.count');
                let currentCount = parseInt(countSpan.innerText);
                countSpan.innerText = currentCount + 1;
                // Update benefits if necessary
            } else {
                // Create new animal with benefits
                let animalName = getAnimalName(item.animal) + 'Special';
                let newAnimal = document.createElement('div');
                newAnimal.classList.add('animal');
                newAnimal.id = animalName;
                newAnimal.innerHTML = `
                    <div class="emoji">${item.animal}</div>
                    <h3>${getAnimalName(item.animal)} (${item.rarity})</h3>
                    <p>Coin Boost: x${item.benefits.coinBoost}</p>
                    <p>Owned: <span class="count">1</span></p>
                    <button onclick="buyMoreSpecial('${animalName}', ${item.cost})" style="margin-top:10px; padding:5px 10px; cursor:pointer;">Buy More</button>
                `;
                animalContainer.appendChild(newAnimal);
            }
        }
        
        function getAnimalName(emoji) {
            const map = {
                'üê∂': 'dog',
                'üê±': 'cat',
                'ü¶ä': 'fox',
                'üê∞': 'rabbit',
                'üêª': 'bear',
                'ü¶Å': 'lion',
                'üêâ': 'dragon',
                'ü¶Ñ': 'unicorn',
                'üê≤': 'dragon',
                'üê∫': 'wolf'
            };
            return map[emoji] || 'animal';
        }
        
        function buyMoreSpecial(animalId, baseCost) {
            let countSpan = document.getElementById(animalId).querySelector('.count');
            let count = parseInt(countSpan.innerText);
            let cost = Math.floor(baseCost * Math.pow(1.5, count)); // Increasing cost
            if (coins >= cost) {
                coins -= cost;
                countSpan.innerText = count + 1;
                tokens += 1; // Reward token for purchase
                playerNetWorth += cost;
                alertInGame(`Purchased another ${getAnimalName(animalId.replace('Special',''))}! +${baseRewards[getAnimalName(animalId.replace('Special',''))] * coinMultiplier} coins.`);
                upgradeSound.play();
                updateCoins();
                updateTokens();
                checkAchievements(null, null);
            } else {
                alertInGame('Not enough coins!');
            }
        }
        
        // NPC Trading System
        function generateNPCs() {
            const names = ['Woody', 'Lily', 'Max', 'Bella', 'Charlie', 'Daisy', 'Rocky', 'Molly', 'Buddy', 'Lucy', 'Jack', 'Luna', 'Oliver', 'Chloe', 'Toby'];
            const categories = ['Bronze', 'Silver', 'Gold', 'Platinum', 'Diamond'];
            let npcList = [];
            categories.forEach((category, catIndex) => {
                for (let i = 0; i < 3; i++) {
                    npcList.push({
                        name: names[catIndex * 3 + i],
                        category: category,
                        contactChance: catIndex + 1, // Higher category, higher chance
                        offeredAnimal: getRandomMythicAnimal(category),
                        pet: getRandomPet(category)
                    });
                }
            });
            return npcList;
        }
        
        function getRandomMythicAnimal(category) {
            const mythicAnimals = {
                'Bronze': 'ü¶Å', // Lion
                'Silver': 'üêâ', // Dragon
                'Gold': 'ü¶Ñ', // Unicorn
                'Platinum': 'üê≤', // Dragon
                'Diamond': 'üê∫'  // Wolf
            };
            return mythicAnimals[category] || 'ü¶ä';
        }
        
        function getRandomPet(category) {
            const pets = {
                'Bronze': { name: 'Pup', rarity: 'Common', benefit: 'moneyBoost', value: 1.1 },
                'Silver': { name: 'Kitty', rarity: 'Uncommon', benefit: 'timeBoost', value: 1.2 },
                'Gold': { name: 'Dragon', rarity: 'Rare', benefit: 'coinMultiplier', value: 1.3 },
                'Platinum': { name: 'Unicorn', rarity: 'Epic', benefit: 'allBoost', value: 1.4 },
                'Diamond': { name: 'Phoenix', rarity: 'Mythic', benefit: 'autoHarvest', value: 1.5 }
            };
            return pets[category] || { name: 'Pet', rarity: 'Common', benefit: 'none', value: 1 };
        }
        
        function renderNPCs() {
            // NPC rendering can be implemented if a specific UI is desired
        }
        
        function startNPCAutoContact() {
            setInterval(() => {
                const chance = Math.random() * 100;
                const threshold = calculateNPCCallThreshold();
                if (chance < threshold) {
                    contactNPC();
                }
            }, 300000); // Every 5 minutes
        }
        
        function calculateNPCCallThreshold() {
            // Higher net worth increases the chance
            // Example: 1% per 1000 coins
            return Math.min(playerNetWorth / 1000, 20); // Max 20% chance
        }
        
        function contactNPC() {
            const filteredNPCs = npcs.filter(npc => Math.random() < (npc.contactChance / 10));
            if (filteredNPCs.length === 0) return;
            const npc = filteredNPCs[Math.floor(Math.random() * filteredNPCs.length)];
            const accept = confirm(`${npc.name} from ${npc.category} category wants to trade! Accept?`);
            if (accept) {
                tokens += 5;
                coins += 500 * coinMultiplier; // Example trade deal
                playerNetWorth += 500 * coinMultiplier;
                alertInGame(`Trade accepted with ${npc.name}! +${500 * coinMultiplier} coins and +5 tokens.`);
                checkQuests(null, 'npc');
                checkAchievements(null, 'npc');
            } else {
                alertInGame(`Trade with ${npc.name} declined.`);
            }
        }
        
        // Pets System
        let availablePets = [
            { name: 'Pup', rarity: 'Common', benefit: 'moneyBoost', value: 1.1 },
            { name: 'Kitty', rarity: 'Uncommon', benefit: 'timeBoost', value: 1.2 },
            { name: 'Dragon', rarity: 'Rare', benefit: 'coinMultiplier', value: 1.3 },
            { name: 'Unicorn', rarity: 'Epic', benefit: 'allBoost', value: 1.4 },
            { name: 'Phoenix', rarity: 'Mythic', benefit: 'autoHarvest', value: 1.5 }
        ];
        let ownedPets = [];
        let equippedPets = [];
        
        function spinPetWheel() {
            if (tokens < 10) {
                alertInGame('Not enough tokens to spin the wheel! Earn more by playing mini-games.');
                return;
            }
            tokens -= 10;
            updateTokens();
            petSound.play();
            const pet = availablePets[Math.floor(Math.random() * availablePets.length)];
            ownedPets.push(pet);
            alertInGame(`You received a ${pet.rarity} Pet: ${pet.name}!`);
            renderOwnedPets();
            checkQuests(null, 'minigame');
            checkAchievements(null, 'minigame');
        }
        
        function renderOwnedPets() {
            const container = document.getElementById('pets-container');
            container.innerHTML = '';
            ownedPets.forEach((pet, index) => {
                let petDiv = document.createElement('div');
                petDiv.classList.add('pet', 'pet-owned');
                petDiv.innerHTML = `
                    <div class="emoji">${getPetEmoji(pet.name)}</div>
                    <h3>${pet.name} (${pet.rarity})</h3>
                    <p>Benefit: ${getBenefitDescription(pet.benefit)}</p>
                    <button onclick="equipPet(${index})" style="margin-top:10px; padding:5px 10px; cursor:pointer;">Equip</button>
                `;
                container.appendChild(petDiv);
            });
        }
        
        function getPetEmoji(name) {
            const map = {
                'Pup': 'üê∂',
                'Kitty': 'üê±',
                'Dragon': 'üêâ',
                'Unicorn': 'ü¶Ñ',
                'Phoenix': 'üî•'
            };
            return map[name] || 'üêæ';
        }
        
        function getBenefitDescription(benefit) {
            const map = {
                'moneyBoost': 'Increase coin earnings by 10%',
                'timeBoost': 'Decrease growth times by 10%',
                'coinMultiplier': 'Increase coin multiplier by 10%',
                'allBoost': 'Increase all earnings by 10%',
                'autoHarvest': 'Automatically harvest crops every 60s'
            };
            return map[benefit] || 'No benefit';
        }
        
        function equipPet(index) {
            if (equippedPets.length >= 2) {
                alertInGame('You can only equip 2 pets at a time.');
                return;
            }
            const pet = ownedPets[index];
            equippedPets.push(pet);
            alertInGame(`${pet.name} equipped! Benefits applied.`);
            applyPetBenefits();
            renderOwnedPets();
        }
        
        function applyPetBenefits() {
            equippedPets.forEach(pet => {
                switch(pet.benefit) {
                    case 'moneyBoost':
                        coinMultiplier *= pet.value;
                        break;
                    case 'timeBoost':
                        for (let crop in growthTimes) {
                            growthTimes[crop] = Math.max(1, growthTimes[crop] / pet.value);
                        }
                        break;
                    case 'coinMultiplier':
                        coinMultiplier *= pet.value;
                        break;
                    case 'allBoost':
                        coinMultiplier *= pet.value;
                        // Apply other benefits if needed
                        break;
                    case 'autoHarvest':
                        // Implement auto-harvest functionality
                        // Example: setInterval to auto-harvest crops
                        setInterval(() => {
                            for (let crop in baseRewards) {
                                coins += baseRewards[crop] * coinMultiplier;
                                playerNetWorth += baseRewards[crop] * coinMultiplier;
                            }
                            updateCoins();
                            alertInGame('Auto-harvested all crops! +10 coins.');
                        }, 60000); // Every 60 seconds
                        break;
                    default:
                        break;
                }
            });
        }
        
        // Mini Games System
        let miniGameCount = 0;
        function openMiniGame(gameName) {
            // Open the mini-game in an iframe or popup
            if (gameName === 'flappyBird') {
                // For simplicity, we'll simulate a mini-game
                playFlappyBird();
            }
            // Additional mini-games can be handled here
        }
        
        function closeMiniGame() {
            const container = document.getElementById('miniGameContainer');
            container.style.display = 'none';
            document.getElementById('miniGameFrame').src = '';
        }
        
        function playFlappyBird() {
            // Simple Flappy Bird-like game implementation
            // For a real implementation, embed an existing mini-game or create a simple version
            // Here, we'll simulate a mini-game with a simple timer
            let gameWindow = window.open('', 'Flappy Bird', 'width=400,height=600');
            gameWindow.document.write(`
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <title>Flappy Farm</title>
                    <style>
                        body { margin: 0; overflow: hidden; background: skyblue; }
                        canvas { display: block; }
                    </style>
                </head>
                <body>
                    <canvas id="flappyCanvas" width="400" height="600"></canvas>
                    <script>
                        const canvas = document.getElementById('flappyCanvas');
                        const ctx = canvas.getContext('2d');
                        let gameOver = false;
                        let score = 0;
                        const startTime = Date.now();
                        
                        // Simple game loop
                        function draw() {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            ctx.fillStyle = 'black';
                            ctx.font = '30px Arial';
                            ctx.fillText('Flappy Farm', 100, 100);
                            ctx.fillText('Press Space to "Flap"', 50, 150);
                        }
        
                        function gameLoop() {
                            if (gameOver) return;
                            draw();
                            // Simple timer-based scoring
                            score = Math.floor((Date.now() - startTime) / 1000);
                            ctx.fillText('Score: ' + score, 150, 200);
                            requestAnimationFrame(gameLoop);
                        }
        
                        window.addEventListener('keydown', function(e){
                            if(e.code === 'Space'){
                                alert('You flapped! Keep going...');
                            }
                        });
        
                        gameLoop();
                    </script>
                </body>
                </html>
            `);
        
            // After a certain time, close the mini-game and reward tokens
            setTimeout(() => {
                gameWindow.close();
                tokens += 2;
                tokenSound.play();
                alertInGame('Mini-Game Completed! +2 Tokens.');
                updateTokens();
                checkQuests(null, 'minigame');
                checkAchievements(null, 'minigame');
            }, 15000); // 15 seconds simulation
        }
        
        // Black Market System Continued
        let blackMarketItems = [];
        function generateBlackMarketItems() {
            const baseAnimals = ['üê∂', 'üê±', 'ü¶ä', 'üê∞', 'üêª'];
            const rarities = ['Common', 'Uncommon', 'Rare', 'Epic', 'Mythic'];
            blackMarketItems = [];
            baseAnimals.forEach(animal => {
                rarities.forEach(rarity => {
                    let cost = 100;
                    switch(rarity) {
                        case 'Common':
                            cost = 100;
                            break;
                        case 'Uncommon':
                            cost = 300;
                            break;
                        case 'Rare':
                            cost = 600;
                            break;
                        case 'Epic':
                            cost = 1000;
                            break;
                        case 'Mythic':
                            cost = 2000;
                            break;
                    }
                    blackMarketItems.push({
                        animal: animal,
                        rarity: rarity,
                        cost: cost,
                        benefits: getBenefitsByRarity(rarity)
                    });
                });
            });
        }
        
        function getBenefitsByRarity(rarity) {
            switch(rarity) {
                case 'Common':
                    return { coinBoost: 1 };
                case 'Uncommon':
                    return { coinBoost: 1.5 };
                case 'Rare':
                    return { coinBoost: 2 };
                case 'Epic':
                    return { coinBoost: 3 };
                case 'Mythic':
                    return { coinBoost: 5 };
                default:
                    return { coinBoost: 1 };
            }
        }
        
        function renderBlackMarket() {
            generateBlackMarketItems();
            const container = document.getElementById('blackmarket-container');
            container.innerHTML = '';
            blackMarketItems.forEach((item, index) => {
                let itemDiv = document.createElement('div');
                itemDiv.classList.add('blackmarket');
                itemDiv.innerHTML = `
                    <div class="emoji">${item.animal}</div>
                    <h3>${item.rarity} Animal</h3>
                    <p>Cost: ${item.cost} coins</p>
                    <button onclick="buyBlackMarketItem(${index})" style="margin-top:10px; padding:5px 10px; cursor:pointer;">Buy</button>
                `;
                container.appendChild(itemDiv);
            });
        }
        
        function buyBlackMarketItem(index) {
            const item = blackMarketItems[index];
            if (coins >= item.cost) {
                coins -= item.cost;
                tokens += 1; // Reward token for purchase
                playerNetWorth += item.cost;
                alertInGame(`Purchased ${item.rarity} Animal ${item.animal}! +${item.benefits.coinBoost}x coins from this animal.`);
                upgradeSound.play();
                addBlackMarketAnimal(item);
                updateCoins();
                updateTokens();
                checkAchievements(null, null);
            } else {
                alertInGame('Not enough coins!');
            }
        }
        
        function addBlackMarketAnimal(item) {
            // Add to animal section with benefits
            const animalContainer = document.getElementById('animals-container');
            let existingAnimal = document.getElementById(getAnimalName(item.animal) + 'Special');
            if (existingAnimal) {
                // If already exists, increment count
                let countSpan = existingAnimal.querySelector('.count');
                let currentCount = parseInt(countSpan.innerText);
                countSpan.innerText = currentCount + 1;
                // Update benefits if necessary
            } else {
                // Create new animal with benefits
                let animalName = getAnimalName(item.animal) + 'Special';
                let newAnimal = document.createElement('div');
                newAnimal.classList.add('animal');
                newAnimal.id = animalName;
                newAnimal.innerHTML = `
                    <div class="emoji">${item.animal}</div>
                    <h3>${getAnimalName(item.animal)} (${item.rarity})</h3>
                    <p>Coin Boost: x${item.benefits.coinBoost}</p>
                    <p>Owned: <span class="count">1</span></p>
                    <button onclick="buyMoreSpecial('${animalName}', ${item.cost})" style="margin-top:10px; padding:5px 10px; cursor:pointer;">Buy More</button>
                `;
                animalContainer.appendChild(newAnimal);
            }
        }
        
        // NPC Trading System Continued
        function generateNPCs() {
            const names = ['Woody', 'Lily', 'Max', 'Bella', 'Charlie', 'Daisy', 'Rocky', 'Molly', 'Buddy', 'Lucy', 'Jack', 'Luna', 'Oliver', 'Chloe', 'Toby'];
            const categories = ['Bronze', 'Silver', 'Gold', 'Platinum', 'Diamond'];
            let npcList = [];
            categories.forEach((category, catIndex) => {
                for (let i = 0; i < 3; i++) {
                    npcList.push({
                        name: names[catIndex * 3 + i],
                        category: category,
                        contactChance: catIndex + 1, // Higher category, higher chance
                        offeredAnimal: getRandomMythicAnimal(category),
                        pet: getRandomPet(category)
                    });
                }
            });
            return npcList;
        }
        
        function getRandomMythicAnimal(category) {
            const mythicAnimals = {
                'Bronze': 'ü¶Å', // Lion
                'Silver': 'üêâ', // Dragon
                'Gold': 'ü¶Ñ',   // Unicorn
                'Platinum': 'üê≤', // Dragon
                'Diamond': 'üê∫' // Wolf
            };
            return mythicAnimals[category] || 'ü¶ä';
        }
        
        function getRandomPet(category) {
            const pets = {
                'Bronze': { name: 'Pup', rarity: 'Common', benefit: 'moneyBoost', value: 1.1 },
                'Silver': { name: 'Kitty', rarity: 'Uncommon', benefit: 'timeBoost', value: 1.2 },
                'Gold': { name: 'Dragon', rarity: 'Rare', benefit: 'coinMultiplier', value: 1.3 },
                'Platinum': { name: 'Unicorn', rarity: 'Epic', benefit: 'allBoost', value: 1.4 },
                'Diamond': { name: 'Phoenix', rarity: 'Mythic', benefit: 'autoHarvest', value: 1.5 }
            };
            return pets[category] || { name: 'Pet', rarity: 'Common', benefit: 'none', value: 1 };
        }
        
        function renderNPCs() {
            // NPC rendering can be implemented if a specific UI is desired
        }
        
        function startNPCAutoContact() {
            setInterval(() => {
                const chance = Math.random() * 100;
                const threshold = calculateNPCCallThreshold();
                if (chance < threshold) {
                    contactNPC();
                }
            }, 300000); // Every 5 minutes
        }
        
        function calculateNPCCallThreshold() {
            // Higher net worth increases the chance
            // Example: 1% per 1000 coins
            return Math.min(playerNetWorth / 1000, 20); // Max 20% chance
        }
        
        function contactNPC() {
            const filteredNPCs = npcs.filter(npc => Math.random() < (npc.contactChance / 10));
            if (filteredNPCs.length === 0) return;
            const npc = filteredNPCs[Math.floor(Math.random() * filteredNPCs.length)];
            const accept = confirm(`${npc.name} from ${npc.category} category wants to trade! Accept?`);
            if (accept) {
                tokens += 5;
                coins += 500 * coinMultiplier; // Example trade deal
                playerNetWorth += 500 * coinMultiplier;
                alertInGame(`Trade accepted with ${npc.name}! +${500 * coinMultiplier} coins and +5 tokens.`);
                checkQuests(null, 'npc');
                checkAchievements(null, 'npc');
            } else {
                alertInGame(`Trade with ${npc.name} declined.`);
            }
        }
        
        // Pets System Continued
        let availablePets = [
            { name: 'Pup', rarity: 'Common', benefit: 'moneyBoost', value: 1.1 },
            { name: 'Kitty', rarity: 'Uncommon', benefit: 'timeBoost', value: 1.2 },
            { name: 'Dragon', rarity: 'Rare', benefit: 'coinMultiplier', value: 1.3 },
            { name: 'Unicorn', rarity: 'Epic', benefit: 'allBoost', value: 1.4 },
            { name: 'Phoenix', rarity: 'Mythic', benefit: 'autoHarvest', value: 1.5 }
        ];
        let ownedPets = [];
        let equippedPets = [];
        
        function spinPetWheel() {
            if (tokens < 10) {
                alertInGame('Not enough tokens to spin the wheel! Earn more by playing mini-games.');
                return;
            }
            tokens -= 10;
            updateTokens();
            petSound.play();
            const pet = availablePets[Math.floor(Math.random() * availablePets.length)];
            ownedPets.push(pet);
            alertInGame(`You received a ${pet.rarity} Pet: ${pet.name}!`);
            renderOwnedPets();
            checkQuests(null, 'minigame');
            checkAchievements(null, 'minigame');
        }
        
        function renderOwnedPets() {
            const container = document.getElementById('pets-container');
            container.innerHTML = '';
            ownedPets.forEach((pet, index) => {
                let petDiv = document.createElement('div');
                petDiv.classList.add('pet', 'pet-owned');
                petDiv.innerHTML = `
                    <div class="emoji">${getPetEmoji(pet.name)}</div>
                    <h3>${pet.name} (${pet.rarity})</h3>
                    <p>Benefit: ${getBenefitDescription(pet.benefit)}</p>
                    <button onclick="equipPet(${index})" style="margin-top:10px; padding:5px 10px; cursor:pointer;">Equip</button>
                `;
                container.appendChild(petDiv);
            });
        }
        
        function getPetEmoji(name) {
            const map = {
                'Pup': 'üê∂',
                'Kitty': 'üê±',
                'Dragon': 'üêâ',
                'Unicorn': 'ü¶Ñ',
                'Phoenix': 'üî•'
            };
            return map[name] || 'üêæ';
        }
        
        function getBenefitDescription(benefit) {
            const map = {
                'moneyBoost': 'Increase coin earnings by 10%',
                'timeBoost': 'Decrease growth times by 10%',
                'coinMultiplier': 'Increase coin multiplier by 10%',
                'allBoost': 'Increase all earnings by 10%',
                'autoHarvest': 'Automatically harvest crops every 60s'
            };
            return map[benefit] || 'No benefit';
        }
        
        function equipPet(index) {
            if (equippedPets.length >= 2) {
                alertInGame('You can only equip 2 pets at a time.');
                return;
            }
            const pet = ownedPets[index];
            equippedPets.push(pet);
            alertInGame(`${pet.name} equipped! Benefits applied.`);
            applyPetBenefits();
            renderOwnedPets();
        }
        
        function applyPetBenefits() {
            equippedPets.forEach(pet => {
                switch(pet.benefit) {
                    case 'moneyBoost':
                        coinMultiplier *= pet.value;
                        break;
                    case 'timeBoost':
                        for (let crop in growthTimes) {
                            growthTimes[crop] = Math.max(1, growthTimes[crop] / pet.value);
                        }
                        break;
                    case 'coinMultiplier':
                        coinMultiplier *= pet.value;
                        break;
                    case 'allBoost':
                        coinMultiplier *= pet.value;
                        // Apply other benefits if needed
                        break;
                    case 'autoHarvest':
                        // Implement auto-harvest functionality
                        // Example: setInterval to auto-harvest crops
                        setInterval(() => {
                            for (let crop in baseRewards) {
                                coins += baseRewards[crop] * coinMultiplier;
                                playerNetWorth += baseRewards[crop] * coinMultiplier;
                            }
                            updateCoins();
                            alertInGame('Auto-harvested all crops! +10 coins.');
                        }, 60000); // Every 60 seconds
                        break;
                    default:
                        break;
                }
            });
        }
        
        // Mini Games System Continued
        let miniGameCount = 0;
        function openMiniGame(gameName) {
            // Open the mini-game in an iframe or popup
            if (gameName === 'flappyBird') {
                // For simplicity, we'll simulate a mini-game
                playFlappyBird();
            }
            // Additional mini-games can be handled here
        }
        
        function closeMiniGame() {
            const container = document.getElementById('miniGameContainer');
            container.style.display = 'none';
            document.getElementById('miniGameFrame').src = '';
        }
        
        function playFlappyBird() {
            // Simple Flappy Bird-like game implementation
            // For a real implementation, embed an existing mini-game or create a simple version
            // Here, we'll simulate a mini-game with a simple timer
            let gameWindow = window.open('', 'Flappy Bird', 'width=400,height=600');
            gameWindow.document.write(`
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <title>Flappy Farm</title>
                    <style>
                        body { margin: 0; overflow: hidden; background: skyblue; }
                        canvas { display: block; }
                    </style>
                </head>
                <body>
                    <canvas id="flappyCanvas" width="400" height="600"></canvas>
                    <script>
                        const canvas = document.getElementById('flappyCanvas');
                        const ctx = canvas.getContext('2d');
                        let gameOver = false;
                        let score = 0;
                        const startTime = Date.now();
                        
                        // Simple game loop
                        function draw() {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            ctx.fillStyle = 'black';
                            ctx.font = '30px Arial';
                            ctx.fillText('Flappy Farm', 100, 100);
                            ctx.fillText('Press Space to "Flap"', 50, 150);
                        }
        
                        function gameLoop() {
                            if (gameOver) return;
                            draw();
                            // Simple timer-based scoring
                            score = Math.floor((Date.now() - startTime) / 1000);
                            ctx.fillText('Score: ' + score, 150, 200);
                            requestAnimationFrame(gameLoop);
                        }
        
                        window.addEventListener('keydown', function(e){
                            if(e.code === 'Space'){
                                alert('You flapped! Keep going...');
                            }
                        });
        
                        gameLoop();
                    </script>
                </body>
                </html>
            `);
        
            // After a certain time, close the mini-game and reward tokens
            setTimeout(() => {
                gameWindow.close();
                tokens += 2;
                tokenSound.play();
                alertInGame('Mini-Game Completed! +2 Tokens.');
                updateTokens();
                checkQuests(null, 'minigame');
                checkAchievements(null, 'minigame');
            }, 15000); // 15 seconds simulation
        }
        
        // Black Market System Continued
        let blackMarketItems = [];
        function generateBlackMarketItems() {
            const baseAnimals = ['üê∂', 'üê±', 'ü¶ä', 'üê∞', 'üêª'];
            const rarities = ['Common', 'Uncommon', 'Rare', 'Epic', 'Mythic'];
            blackMarketItems = [];
            baseAnimals.forEach(animal => {
                rarities.forEach(rarity => {
                    let cost = 100;
                    switch(rarity) {
                        case 'Common':
                            cost = 100;
                            break;
                        case 'Uncommon':
                            cost = 300;
                            break;
                        case 'Rare':
                            cost = 600;
                            break;
                        case 'Epic':
                            cost = 1000;
                            break;
                        case 'Mythic':
                            cost = 2000;
                            break;
                    }
                    blackMarketItems.push({
                        animal: animal,
                        rarity: rarity,
                        cost: cost,
                        benefits: getBenefitsByRarity(rarity)
                    });
                });
            });
        }
        
        function getBenefitsByRarity(rarity) {
            switch(rarity) {
                case 'Common':
                    return { coinBoost: 1 };
                case 'Uncommon':
                    return { coinBoost: 1.5 };
                case 'Rare':
                    return { coinBoost: 2 };
                case 'Epic':
                    return { coinBoost: 3 };
                case 'Mythic':
                    return { coinBoost: 5 };
                default:
                    return { coinBoost: 1 };
            }
        }
        
        function renderBlackMarket() {
            generateBlackMarketItems();
            const container = document.getElementById('blackmarket-container');
            container.innerHTML = '';
            blackMarketItems.forEach((item, index) => {
                let itemDiv = document.createElement('div');
                itemDiv.classList.add('blackmarket');
                itemDiv.innerHTML = `
                    <div class="emoji">${item.animal}</div>
                    <h3>${item.rarity} Animal</h3>
                    <p>Cost: ${item.cost} coins</p>
                    <button onclick="buyBlackMarketItem(${index})" style="margin-top:10px; padding:5px 10px; cursor:pointer;">Buy</button>
                `;
                container.appendChild(itemDiv);
            });
        }
        
        function buyBlackMarketItem(index) {
            const item = blackMarketItems[index];
            if (coins >= item.cost) {
                coins -= item.cost;
                tokens += 1; // Reward token for purchase
                playerNetWorth += item.cost;
                alertInGame(`Purchased ${item.rarity} Animal ${item.animal}! +${item.benefits.coinBoost}x coins from this animal.`);
                upgradeSound.play();
                addBlackMarketAnimal(item);
                updateCoins();
                updateTokens();
                checkAchievements(null, null);
            } else {
                alertInGame('Not enough coins!');
            }
        }
        
        function addBlackMarketAnimal(item) {
            // Add to animal section with benefits
            const animalContainer = document.getElementById('animals-container');
            let existingAnimal = document.getElementById(getAnimalName(item.animal) + 'Special');
            if (existingAnimal) {
                // If already exists, increment count
                let countSpan = existingAnimal.querySelector('.count');
                let currentCount = parseInt(countSpan.innerText);
                countSpan.innerText = currentCount + 1;
                // Update benefits if necessary
            } else {
                // Create new animal with benefits
                let animalName = getAnimalName(item.animal) + 'Special';
                let newAnimal = document.createElement('div');
                newAnimal.classList.add('animal');
                newAnimal.id = animalName;
                newAnimal.innerHTML = `
                    <div class="emoji">${item.animal}</div>
                    <h3>${getAnimalName(item.animal)} (${item.rarity})</h3>
                    <p>Coin Boost: x${item.benefits.coinBoost}</p>
                    <p>Owned: <span class="count">1</span></p>
                    <button onclick="buyMoreSpecial('${animalName}', ${item.cost})" style="margin-top:10px; padding:5px 10px; cursor:pointer;">Buy More</button>
                `;
                animalContainer.appendChild(newAnimal);
            }
        }
        
        // NPC Trading System Continued
        function generateNPCs() {
            const names = ['Woody', 'Lily', 'Max', 'Bella', 'Charlie', 'Daisy', 'Rocky', 'Molly', 'Buddy', 'Lucy', 'Jack', 'Luna', 'Oliver', 'Chloe', 'Toby'];
            const categories = ['Bronze', 'Silver', 'Gold', 'Platinum', 'Diamond'];
            let npcList = [];
            categories.forEach((category, catIndex) => {
                for (let i = 0; i < 3; i++) {
                    npcList.push({
                        name: names[catIndex * 3 + i],
                        category: category,
                        contactChance: catIndex + 1, // Higher category, higher chance
                        offeredAnimal: getRandomMythicAnimal(category),
                        pet: getRandomPet(category)
                    });
                }
            });
            return npcList;
        }
        
        function getRandomMythicAnimal(category) {
            const mythicAnimals = {
                'Bronze': 'ü¶Å', // Lion
                'Silver': 'üêâ', // Dragon
                'Gold': 'ü¶Ñ',   // Unicorn
                'Platinum': 'üê≤', // Dragon
                'Diamond': 'üê∫'  // Wolf
            };
            return mythicAnimals[category] || 'ü¶ä';
        }
        
        function getRandomPet(category) {
            const pets = {
                'Bronze': { name: 'Pup', rarity: 'Common', benefit: 'moneyBoost', value: 1.1 },
                'Silver': { name: 'Kitty', rarity: 'Uncommon', benefit: 'timeBoost', value: 1.2 },
                'Gold': { name: 'Dragon', rarity: 'Rare', benefit: 'coinMultiplier', value: 1.3 },
                'Platinum': { name: 'Unicorn', rarity: 'Epic', benefit: 'allBoost', value: 1.4 },
                'Diamond': { name: 'Phoenix', rarity: 'Mythic', benefit: 'autoHarvest', value: 1.5 }
            };
            return pets[category] || { name: 'Pet', rarity: 'Common', benefit: 'none', value: 1 };
        }
        
        function renderNPCs() {
            // NPC rendering can be implemented if a specific UI is desired
        }
        
        function startNPCAutoContact() {
            setInterval(() => {
                const chance = Math.random() * 100;
                const threshold = calculateNPCCallThreshold();
                if (chance < threshold) {
                    contactNPC();
                }
            }, 300000); // Every 5 minutes
        }
        
        function calculateNPCCallThreshold() {
            // Higher net worth increases the chance
            // Example: 1% per 1000 coins
            return Math.min(playerNetWorth / 1000, 20); // Max 20% chance
        }
        
        function contactNPC() {
            const filteredNPCs = npcs.filter(npc => Math.random() < (npc.contactChance / 10));
            if (filteredNPCs.length === 0) return;
            const npc = filteredNPCs[Math.floor(Math.random() * filteredNPCs.length)];
            const accept = confirm(`${npc.name} from ${npc.category} category wants to trade! Accept?`);
            if (accept) {
                tokens += 5;
                coins += 500 * coinMultiplier; // Example trade deal
                playerNetWorth += 500 * coinMultiplier;
                alertInGame(`Trade accepted with ${npc.name}! +${500 * coinMultiplier} coins and +5 tokens.`);
                checkQuests(null, 'npc');
                checkAchievements(null, 'npc');
            } else {
                alertInGame(`Trade with ${npc.name} declined.`);
            }
        }
        
        // Pets System Continued
        let availablePets = [
            { name: 'Pup', rarity: 'Common', benefit: 'moneyBoost', value: 1.1 },
            { name: 'Kitty', rarity: 'Uncommon', benefit: 'timeBoost', value: 1.2 },
            { name: 'Dragon', rarity: 'Rare', benefit: 'coinMultiplier', value: 1.3 },
            { name: 'Unicorn', rarity: 'Epic', benefit: 'allBoost', value: 1.4 },
            { name: 'Phoenix', rarity: 'Mythic', benefit: 'autoHarvest', value: 1.5 }
        ];
        let ownedPets = [];
        let equippedPets = [];
        
        function spinPetWheel() {
            if (tokens < 10) {
                alertInGame('Not enough tokens to spin the wheel! Earn more by playing mini-games.');
                return;
            }
            tokens -= 10;
            updateTokens();
            petSound.play();
            const pet = availablePets[Math.floor(Math.random() * availablePets.length)];
            ownedPets.push(pet);
            alertInGame(`You received a ${pet.rarity} Pet: ${pet.name}!`);
            renderOwnedPets();
            checkQuests(null, 'minigame');
            checkAchievements(null, 'minigame');
        }
        
        function renderOwnedPets() {
            const container = document.getElementById('pets-container');
            container.innerHTML = '';
            ownedPets.forEach((pet, index) => {
                let petDiv = document.createElement('div');
                petDiv.classList.add('pet', 'pet-owned');
                petDiv.innerHTML = `
                    <div class="emoji">${getPetEmoji(pet.name)}</div>
                    <h3>${pet.name} (${pet.rarity})</h3>
                    <p>Benefit: ${getBenefitDescription(pet.benefit)}</p>
                    <button onclick="equipPet(${index})" style="margin-top:10px; padding:5px 10px; cursor:pointer;">Equip</button>
                `;
                container.appendChild(petDiv);
            });
        }
        
        function getPetEmoji(name) {
            const map = {
                'Pup': 'üê∂',
                'Kitty': 'üê±',
                'Dragon': 'üêâ',
                'Unicorn': 'ü¶Ñ',
                'Phoenix': 'üî•'
            };
            return map[name] || 'üêæ';
        }
        
        function getBenefitDescription(benefit) {
            const map = {
                'moneyBoost': 'Increase coin earnings by 10%',
                'timeBoost': 'Decrease growth times by 10%',
                'coinMultiplier': 'Increase coin multiplier by 10%',
                'allBoost': 'Increase all earnings by 10%',
                'autoHarvest': 'Automatically harvest crops every 60s'
            };
            return map[benefit] || 'No benefit';
        }
        
        function equipPet(index) {
            if (equippedPets.length >= 2) {
                alertInGame('You can only equip 2 pets at a time.');
                return;
            }
            const pet = ownedPets[index];
            equippedPets.push(pet);
            alertInGame(`${pet.name} equipped! Benefits applied.`);
            applyPetBenefits();
            renderOwnedPets();
        }
        
        function applyPetBenefits() {
            equippedPets.forEach(pet => {
                switch(pet.benefit) {
                    case 'moneyBoost':
                        coinMultiplier *= pet.value;
                        break;
                    case 'timeBoost':
                        for (let crop in growthTimes) {
                            growthTimes[crop] = Math.max(1, growthTimes[crop] / pet.value);
                        }
                        break;
                    case 'coinMultiplier':
                        coinMultiplier *= pet.value;
                        break;
                    case 'allBoost':
                        coinMultiplier *= pet.value;
                        // Apply other benefits if needed
                        break;
                    case 'autoHarvest':
                        // Implement auto-harvest functionality
                        // Example: setInterval to auto-harvest crops
                        setInterval(() => {
                            for (let crop in baseRewards) {
                                coins += baseRewards[crop] * coinMultiplier;
                                playerNetWorth += baseRewards[crop] * coinMultiplier;
                            }
                            updateCoins();
                            alertInGame('Auto-harvested all crops! +10 coins.');
                        }, 60000); // Every 60 seconds
                        break;
                    default:
                        break;
                }
            });
        }
        
        // Achievements System Continued
        function checkAchievements(item, type) {
            for (let key in achievements) {
                let ach = achievements[key];
                if (!ach.achieved) {
                    if (ach.type === 'crop' && ach.item === item) {
                        ach.count += 1;
                        if (ach.count >= ach.goal) {
                            ach.achieved = true;
                            gems += parseReward(ach.reward);
                            achievementSound.play();
                            alertInGame(`Achievement Unlocked: ${ach.description} +${ach.reward}`);
                        }
                    }
                    if (ach.type === 'animal' && ach.item === item) {
                        ach.count += 1;
                        if (ach.count >= ach.goal) {
                            ach.achieved = true;
                            gems += parseReward(ach.reward);
                            achievementSound.play();
                            alertInGame(`Achievement Unlocked: ${ach.description} +${ach.reward}`);
                        }
                    }
                    if (ach.type === 'coins' && ach.item === null) {
                        if (coins >= ach.goal) {
                            ach.achieved = true;
                            gems += parseReward(ach.reward);
                            achievementSound.play();
                            alertInGame(`Achievement Unlocked: ${ach.description} +${ach.reward}`);
                        }
                    }
                    if (ach.type === 'upgrade' && ach.item === item) {
                        if (item === 'market' && coinMultiplier > 1) { // Assuming market increases multiplier
                            ach.achieved = true;
                            gems += parseReward(ach.reward);
                            achievementSound.play();
                            alertInGame(`Achievement Unlocked: ${ach.description} +${ach.reward}`);
                        }
                    }
                    if (ach.type === 'prestige' && ach.item === null) {
                        if (prestigeCount >= ach.goal) {
                            ach.achieved = true;
                            gems += parseReward(ach.reward);
                            achievementSound.play();
                            alertInGame(`Achievement Unlocked: ${ach.description} +${ach.reward}`);
                        }
                    }
                    if (ach.type === 'passive' && ach.item === null) {
                        if (getOwnedPassiveFarms().length >= ach.goal) {
                            ach.achieved = true;
                            gems += parseReward(ach.reward);
                            achievementSound.play();
                            alertInGame(`Achievement Unlocked: ${ach.description} +${ach.reward}`);
                        }
                    }
                    if (ach.type === 'minigame' && ach.item === null) {
                        // Increment when mini-game is played
                        ach.count += 1;
                        if (ach.count >= ach.goal) {
                            ach.achieved = true;
                            tokens += parseReward(ach.reward);
                            achievementSound.play();
                            alertInGame(`Achievement Unlocked: ${ach.description} +${ach.reward}`);
                        }
                    }
                    if (ach.type === 'pet' && ach.item === null) {
                        if (getOwnedPets().length >= ach.goal) {
                            ach.achieved = true;
                            tokens += parseReward(ach.reward);
                            achievementSound.play();
                            alertInGame(`Achievement Unlocked: ${ach.description} +${ach.reward}`);
                        }
                    }
                    if (ach.type === 'npc' && ach.item === null) {
                        ach.count += 1;
                        if (ach.count >= ach.goal) {
                            ach.achieved = true;
                            tokens += parseReward(ach.reward);
                            achievementSound.play();
                            alertInGame(`Achievement Unlocked: ${ach.description} +${ach.reward}`);
                        }
                    }
                }
            }
            renderAchievements();
            updateGems();
            updateTokens();
        }
        
        function parseReward(reward) {
            // Parse reward strings like '10 Gems' or '50 Tokens'
            const parts = reward.split(' ');
            if(parts[1] === 'Gems') {
                return parseInt(parts[0]);
            } else if(parts[1] === 'Tokens') {
                return parseInt(parts[0]);
            }
            return 0;
        }
        
        function renderAchievements() {
            const container = document.getElementById('achievements-container');
            container.innerHTML = '';
            for (let key in achievements) {
                let ach = achievements[key];
                let achDiv = document.createElement('div');
                achDiv.classList.add('achievement');
                achDiv.innerHTML = `<h4>${ach.achieved ? '‚úÖ' : 'üîÑ'} ${ach.description}</h4><p>Reward: ${ach.reward}</p>`;
                container.appendChild(achDiv);
            }
        }
        
        // Quests System Continued
        function generateQuests() {
            const questList = [
                { id: 'quest1', description: 'Harvest 20 Wheat', goal: 20, type: 'crop', item: 'wheat', reward: 100 },
                { id: 'quest2', description: 'Collect 500 Coins', goal: 500, type: 'coins', item: null, reward: 50 },
                { id: 'quest3', description: 'Buy 2 Upgrades', goal: 2, type: 'upgrade', item: null, reward: 150 },
                { id: 'quest4', description: 'Raise 10 Chickens', goal: 10, type: 'animal', item: 'chicken', reward: 200 },
                { id: 'quest5', description: 'Own 1 Passive Farm', goal: 1, type: 'passive', item: null, reward: 300 },
                { id: 'quest6', description: 'Play 5 Mini Games', goal: 5, type: 'minigame', item: null, reward: '50 Tokens' },
                { id: 'quest7', description: 'Own 3 Pets', goal: 3, type: 'pet', item: null, reward: '100 Tokens' },
                { id: 'quest8', description: 'Trade with 2 NPCs', goal: 2, type: 'npc', item: null, reward: '150 Tokens' }
            ];
            quests = questList.filter(q => !completedQuests.includes(q.id));
        }
        
        function checkQuests(item, type) {
            quests.forEach(quest => {
                if (!completedQuests.includes(quest.id)) {
                    if (quest.type === 'crop' && quest.item === item) {
                        quest.count = (quest.count || 0) + 1;
                        if (quest.count >= quest.goal) {
                            completeQuest(quest);
                        }
                    }
                    if (quest.type === 'animal' && quest.item === item) {
                        quest.count = (quest.count || 0) + 1;
                        if (quest.count >= quest.goal) {
                            completeQuest(quest);
                        }
                    }
                    if (quest.type === 'coins' && quest.item === null) {
                        if (coins >= quest.goal) {
                            completeQuest(quest);
                        }
                    }
                    if (quest.type === 'upgrade' && quest.item === null) {
                        // Assuming each upgrade counts as one
                        quest.count = (quest.count || 0) + 1;
                        if (quest.count >= quest.goal) {
                            completeQuest(quest);
                        }
                    }
                    if (quest.type === 'passive' && quest.item === null) {
                        if (getOwnedPassiveFarms().length >= quest.goal) {
                            completeQuest(quest);
                        }
                    }
                    if (quest.type === 'minigame' && quest.item === null) {
                        // Increment when mini-game is played
                        quest.count = (quest.count || 0) + 1;
                        if (quest.count >= quest.goal) {
                            completeQuest(quest);
                        }
                    }
                    if (quest.type === 'pet' && quest.item === null) {
                        if (getOwnedPets().length >= quest.goal) {
                            completeQuest(quest);
                        }
                    }
                    if (quest.type === 'npc' && quest.item === null) {
                        quest.count = (quest.count || 0) + 1;
                        if (quest.count >= quest.goal) {
                            completeQuest(quest);
                        }
                    }
                }
            });
        }
        
        function completeQuest(quest) {
            let reward = quest.reward;
            if (reward.includes('Gems')) {
                gems += parseInt(reward);
            } else if (reward.includes('Tokens')) {
                tokens += parseInt(reward);
            } else {
                coins += parseInt(reward);
                playerNetWorth += parseInt(reward);
            }
            alertInGame(`Quest Completed: ${quest.description} +${reward}`);
            completedQuests.push(quest.id);
            quests = quests.filter(q => q.id !== quest.id);
            generateQuests();
            renderQuests();
            updateCoins();
            updateGems();
            updateTokens();
            checkAchievements(quest.item, quest.type);
        }
        
        function renderQuests() {
            const container = document.getElementById('quests-container');
            container.innerHTML = '';
            quests.forEach(quest => {
                if (!completedQuests.includes(quest.id)) {
                    let questDiv = document.createElement('div');
                    questDiv.classList.add('quest');
                    questDiv.innerHTML = `<h4>${quest.description}</h4><p>Reward: ${quest.reward}</p>`;
                    container.appendChild(questDiv);
                }
            });
        }
        
        // Prestige Functionality
        function prestige() {
            if (coins >= 1000) {
                coins -= 1000;
                prestigeCount += 1;
                coinMultiplier += 0.5; // Increase multiplier
                updateCoins();
                updatePrestige();
                prestigeSound.play();
                alertInGame('Prestige achieved! ‚ú® Coin rewards increased by 50%.');
                checkAchievements(null, null); // For prestige-related achievements
                resetGame(true); // Complete reset
            } else {
                alertInGame('Not enough coins to prestige!');
            }
        }
        
        // Passive Farms Helper
        function getOwnedPassiveFarms() {
            let owned = [];
            document.querySelectorAll('.passive-farm.owned').forEach(el => owned.push(el.id));
            return owned;
        }
        
        // Toggle Focus Mode
        function toggleFocusMode() {
            focusMode = !focusMode;
            const farmSections = document.querySelectorAll('.section');
            farmSections.forEach(section => {
                if (!['Crops üå±', 'Animals üêÑ', 'Upgrades üöú', 'Passive Farms üåæ', 'Decorations üé®', 'Quests üéØ', 'Achievements üèÜ', 'Pets üêæ', 'Black Market üí±', 'Mini Games üïπÔ∏è', 'Prestige ‚ú®'].includes(section.querySelector('h2')?.innerText)) {
                    section.style.display = focusMode ? 'none' : 'block';
                }
            });
            document.getElementById('focus-mode-toggle').innerText = focusMode ? 'üîì Focus Mode' : 'üîí Focus Mode';
        }
        
        // Toggle Theme
        function toggleTheme() {
            theme = (theme === 'light') ? 'dark' : 'light';
            updateTheme();
        }
        
        function updateTheme() {
            if (theme === 'dark') {
                document.body.classList.add('dark-mode');
            } else {
                document.body.classList.remove('dark-mode');
            }
            // Save theme preference
            saveGame();
        }
        
        // Daily Bonus System
        function checkDailyBonus() {
            const lastLogin = localStorage.getItem('lastLogin');
            const today = new Date().toDateString();
            if (lastLogin !== today && !dailyBonusClaimed) {
                showDailyBonus();
                localStorage.setItem('lastLogin', today);
            }
        }
        
        function showDailyBonus() {
            gems += 5;
            dailyBonusSound.play();
            alertInGame('Daily Bonus! +5 Gems! üåü');
            dailyBonusClaimed = true;
            updateGems();
        }
        
        // Reset Daily Bonus
        function resetDailyBonus() {
            dailyBonusClaimed = false;
        }
        
        // Automatically reset daily bonus at midnight
        setInterval(() => {
            const now = new Date();
            if (now.getHours() === 0 && now.getMinutes() === 0) {
                resetDailyBonus();
            }
        }, 60000); // Check every minute
        
        // Strategy Tips
        function showStrategyTip() {
            const tips = [
                "Focus on upgrading wheat and chicken early to maximize your income.",
                "Invest in passive farms to earn coins even when you're not actively playing.",
                "Complete daily quests for additional rewards and progression.",
                "Prestiging can significantly boost your coin earnings over time.",
                "Balance your investments between crops and animals for steady income."
            ];
            const randomTip = tips[Math.floor(Math.random() * tips.length)];
            alertInGame(`Strategy Tip: ${randomTip}`);
        }
        
        // Periodically show strategy tips
        setInterval(showStrategyTip, 300000); // Every 5 minutes
        
        // Capitalize Function
        function capitalize(string) {
            return string.charAt(0).toUpperCase() + string.slice(1);
        }
        
        // Accessibility: Keyboard Navigation
        document.addEventListener('keydown', function(event) {
            switch(event.key.toLowerCase()) {
                case 'c':
                    document.querySelector('.section:nth-of-type(2)').scrollIntoView();
                    break;
                case 'a':
                    document.querySelector('.section:nth-of-type(3)').scrollIntoView();
                    break;
                case 'u':
                    document.querySelector('.section:nth-of-type(4)').scrollIntoView();
                    break;
                case 'p':
                    document.querySelector('.section:nth-of-type(10)').scrollIntoView();
                    break;
                case 'd':
                    document.querySelector('.section:nth-of-type(5)').scrollIntoView();
                    break;
                case 'q':
                    document.querySelector('.section:nth-of-type(7)').scrollIntoView();
                    break;
                case 'm':
                    document.querySelector('.section:nth-of-type(9)').scrollIntoView();
                    break;
                default:
                    break;
            }
        });
        
        // Auto-Save Functionality and Notification
        function showAutoSaveNotification() {
            setInterval(() => {
                saveGame();
                const notification = document.getElementById('auto-save-notification');
                notification.style.display = 'block';
                notification.style.opacity = '1';
                setTimeout(() => {
                    notification.style.opacity = '0';
                    setTimeout(() => {
                        notification.style.display = 'none';
                    }, 500);
                }, 2000);
            }, 60000); // Auto-save every 60 seconds
        }
        
        // Hidden Credits (Obfuscated)
        // C-r-e-a-t-e-d b-y: s-t-a-t-i-c
        // W-e-b-s-i-t-e: s-i-t-e-s.-g-o-o-g-l-e.-c-o-m/-v-i-e-w/s-t-a-t-i-c-q-u-a-s-a-r931
        // s-t-a-t-i-c-g-a-m-e
    </script>
</body>
</html>
